/*
// TODO: these are causing syntax error
#define function initialize(address,address,bytes32[],bytes[]) returns ()
#define function execute(bytes32[],bytes[]) returns (bytes[])
*/

/* Storage Slots */
#define constant CALLER_LOCATION = FREE_STORAGE_POINTER()
#define constant VM_LOCATION = FREE_STORAGE_POINTER()



/* Methods */

// Require that msg.sender is CALLER_LOCATION
#define macro ONLY_CALLER() = takes(0) returns(0) {
	[CALLER_LOCATION] sload caller eq is_caller jumpi
		0x00 0x00 revert
	is_caller:
}

// Copy all calldata to memory (memory location provided in stack)
// Current Stack: [0x00]
#define macro COPY_CALLDATA() = takes(1) returns (2) {
    calldatasize            // [ 0x00 calldatasize ]
    dup1                    // [ 0x00 calldatasize calldatasize ]
    dup3                    // [ 0x00 calldatasize calldatasize 0x00 ]
    dup4                    // [ 0x00 calldatasize calldatasize 0x00 0x00 ]
    calldatacopy            // [ 0x00 calldatasize ]
}


// Current Stack: [ 0x00 success returndatasize ]
#define macro CHECK_RETURN() = takes(3) returns (2) {
    swap2                   // [ returndatasize success 0x00 ]
    swap1                   // [ returndatasize 0x00 success ]
    // TODO: Jumping to revert fails.
    0x01
    eq                  // [ returndatasize 0x00 (success==0) ]
    is_success
    jumpi                   // [ returndatasize 0x00 ]
    // TODO: revert msg
    0x00 0x00 revert

    is_success: 
        
}

// Copy return data to memory
// Current Stack: [ 0x00 success ]
#define macro COPY_RETURN_DATA() = takes(2) returns (3) {
    returndatasize          // [ 0x00 success returndatasize ]
    dup1                    // [ 0x00 success returndatasize returndatasize ]
    dup4                    // [ 0x00 success returndatasize returndatsize 0x00 ]
    // this takes advantage of return_data_ptr == 0x00
    dup5                    // [ 0x00 success returndatasize returndatsize 0x00 0x00 ]
    returndatacopy          // [ 0x00 success returndatasize ]
}

// Call VM with commands and state
#define macro EXECUTE() = takes(0) returns (0) {
    ONLY_CALLER()
    0x00
    COPY_CALLDATA()         // [0x00 calldatasize]
    // call(g, a, v, in, insize, out, outsize)
    dup2                    // [ 0x00 calldatasize 0x00 ]
    dup3                    // [ 0x00 calldatasize 0x00 0x00 ]
    swap2                   // [ 0x00 0x00 0x00 calldatasize ]
    dup4                    // [ 0x00 0x00 0x00 calldatasize 0x00 ]
    callvalue               // [ 0x00 0x00 0x00 calldatasize 0x00 msg.value]
    [VM_LOCATION] sload     // [ 0x00 0x00 0x00 calldatasize 0x00 msg.value VM() ]
    gas                     // [ 0x00 0x00 0x00 calldatasize 0x00 msg.value VM() gas ]
    call                    // [ 0x00 success ]
    COPY_RETURN_DATA()      // [ 0x00 success returndatasize]
    CHECK_RETURN()          // [returndatasize, 0x00]
    return
}

#define macro INITIALIZE() = takes(0) returns (0) {
    0x24 calldataload           // [caller]
    [CALLER_LOCATION] sstore    // []
    0x04 calldataload           // [vm]
    [VM_LOCATION] sstore        // []
    
    // TODO: make execute logic internal + call
}



//                                               Dynamic data calldata layout (arrays & bytes)
// 
//     fn sig              position in calldata                other basic params                array length                 actual data
//    <0x34f7a25>               <0x40>                               <...>                          <0x2>                    <"data"><"data">
//
// 
// TODO: how are arrays of bytes laid out? 
// execute(bytes32[], bytes[]) calldata is laid out as follows:
//       4                32                   32                 32                      32 / each
// [function-sig][commandsDataLocation][stateDataLocation][commandsArrayLength][<command>, <command>, etc..][stateArrayLength??][<state>, <state>]]
//


#define macro MAIN() = takes (0) returns (0) {
    // Get function selector and jump to it
    0x00			// [offset]
	calldataload	// [value]
	0xe0			// [shift, value]
	shr			    // [selector]
	dup1			// [selector, selector]

    // execute()
    0xde792d5f      // [executeSelector, selector]
    	eq			// [isExecuteSelector, selector]
		execute			// [jumpdest, isExecuteSelector, selector]
		jumpi		// [selector]

    // initialize()
    0x1f7c1bac      // [initializeSelector, selector]
   		eq          // [isHashSelector]
		initialize  // [jumpdest, isHashSelector]
		jumpi       // []

    execute:
        EXECUTE()
    
    initialize:
        INITIALIZE()

}

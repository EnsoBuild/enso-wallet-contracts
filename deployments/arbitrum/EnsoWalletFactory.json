{
  "address": "0x8C358f8B7b36Ab76b9Dd3711FBe253598fe6aa87",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "EnsoWallet_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract EnsoWallet",
          "name": "instance",
          "type": "address"
        }
      ],
      "name": "Deployed",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "commands",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes[]",
          "name": "state",
          "type": "bytes[]"
        }
      ],
      "name": "deploy",
      "outputs": [
        {
          "internalType": "contract EnsoWallet",
          "name": "instance",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ensoWallet",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAddress",
      "outputs": [
        {
          "internalType": "address payable",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xa69d5595e8dc30994081455ddbbe8583e1a4da758936a204450c65a3a2d475c8",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xf754916D90B109AE8E405FD34064cF6Df23947eb",
    "contractAddress": null,
    "transactionIndex": 1,
    "gasUsed": "713245",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb0ad11e58bdd938ddb475de6bf938e1d242f0bd19c55b2f26896e57f29e29734",
    "transactionHash": "0xa69d5595e8dc30994081455ddbbe8583e1a4da758936a204450c65a3a2d475c8",
    "logs": [],
    "blockNumber": 28462999,
    "cumulativeGasUsed": "713245",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xD422acd2C55A971DA69F5788B66454f2a157F3c7"
  ],
  "numDeployments": 2,
  "solcInputHash": "7ee77f3666f6bda2492068d759696792",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"EnsoWallet_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract EnsoWallet\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"commands\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"state\",\"type\":\"bytes[]\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"contract EnsoWallet\",\"name\":\"instance\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensoWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/EnsoWalletFactory.sol\":\"EnsoWalletFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"@ensofinance/weiroll/contracts/CommandBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary CommandBuilder {\\n    uint256 constant IDX_VARIABLE_LENGTH = 0x80;\\n    uint256 constant IDX_VALUE_MASK = 0x7f;\\n    uint256 constant IDX_END_OF_ARGS = 0xff;\\n    uint256 constant IDX_USE_STATE = 0xfe;\\n    uint256 constant IDX_DYNAMIC_START = 0xfd;\\n    uint256 constant IDX_DYNAMIC_END = 0xfc;\\n\\n    function buildInputs(\\n        bytes[] memory state,\\n        bytes4 selector,\\n        bytes32 indices\\n    ) internal view returns (bytes memory ret) {\\n        uint256 idx; // The current command index\\n        uint256 offsetIdx; // The index of the current offset\\n\\n        uint256 count; // Number of bytes in whole ABI encoded message\\n        uint256 free; // Pointer to first free byte in tail part of message\\n        uint256 offset; // Pointer to the first free byte for variable length data inside dynamic types\\n\\n        uint256[] memory offsets = new uint256[](10); // Optionally store the length of all dynamic types (a command cannot fit more than 10 dynamic types)\\n        bytes memory stateData; // Optionally encode the current state if the call requires it\\n\\n        uint256 indicesLength; // Number of indices\\n\\n        // Determine the length of the encoded data\\n        for (uint256 i; i < 32; ) {\\n            idx = uint8(indices[i]);\\n            if (idx == IDX_END_OF_ARGS) {\\n                indicesLength = i;\\n                break;\\n            }\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    if (stateData.length == 0) {\\n                        stateData = abi.encode(state);\\n                    }\\n                    unchecked {\\n                        free += 32;\\n                        count += stateData.length;\\n                    }\\n                } else if (idx == IDX_DYNAMIC_START) {\\n                    offset = 1; // Semantically overloading the offset to work as a boolean\\n                } else if (idx == IDX_DYNAMIC_END) {\\n                    unchecked {\\n                        offsets[offsetIdx] = offset - 1; // Remove 1 that was set at the start of the dynamic type, to get correct offset length\\n                    }\\n                    offset = 0;\\n                    // Increase count and free for dynamic type pointer\\n                    unchecked {\\n                        offsetIdx++;\\n                        free += 32;\\n                        count += 32;\\n                    }\\n                } else {\\n                    // Add the size of the value, rounded up to the next word boundary, plus space for pointer and length\\n                    uint256 argLen = state[idx & IDX_VALUE_MASK].length;\\n                    require(\\n                        argLen % 32 == 0,\\n                        \\\"Dynamic state variables must be a multiple of 32 bytes\\\"\\n                    );\\n                    unchecked {\\n                        count += argLen + 32;\\n                    }\\n                    if (offset != 0) {\\n                        // Increase offset size\\n                        unchecked {\\n                            offset += 32;\\n                        }\\n                    } else {\\n                        // Progress next free slot\\n                        unchecked {\\n                            free += 32;\\n                        }\\n                    }\\n                }\\n            } else {\\n                require(\\n                    state[idx & IDX_VALUE_MASK].length == 32,\\n                    \\\"Static state variables must be 32 bytes\\\"\\n                );\\n                unchecked {\\n                    count += 32;\\n                }\\n                if (offset != 0) {\\n                    unchecked {\\n                        offset += 32;\\n                    }\\n                } else {\\n                    unchecked {\\n                        free += 32;\\n                    }\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Encode it\\n        ret = new bytes(count + 4);\\n        assembly {\\n            mstore(add(ret, 32), selector)\\n        }\\n        count = 0;\\n        offsetIdx = 0;\\n        for (uint256 i; i < indicesLength; ) {\\n            idx = uint8(indices[i]);\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    memcpy(stateData, 32, ret, free + 4, stateData.length - 32);\\n                    unchecked {\\n                        free += stateData.length - 32;\\n                        count += 32;\\n                    }\\n                } else if (idx == IDX_DYNAMIC_START) {\\n                    // Start of dynamic type, put pointer in current slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    unchecked {\\n                        offset = free + offsets[offsetIdx];\\n                        count += 32;\\n                    }\\n                } else if (idx == IDX_DYNAMIC_END) {\\n                    offset = 0;\\n                    unchecked {\\n                        offsetIdx++;\\n                    }\\n                } else {\\n                    // Variable length data\\n                    uint256 argLen = state[idx & IDX_VALUE_MASK].length;\\n\\n                    if (offset != 0) {\\n                        // Part of dynamic type; put a pointer in the first free slot and write the data to the offset free slot\\n                        uint256 pointer = offsets[offsetIdx];\\n                        assembly {\\n                            mstore(add(add(ret, 36), free), pointer)\\n                        }\\n                        unchecked {\\n                            free += 32;\\n                        }\\n                        memcpy(\\n                            state[idx & IDX_VALUE_MASK],\\n                            0,\\n                            ret,\\n                            offset + 4,\\n                            argLen\\n                        );\\n                        unchecked {\\n                            offsets[offsetIdx] += argLen;\\n                            offset += argLen;\\n                        }\\n                    } else {\\n                        // Put a pointer in the current slot and write the data to first free slot\\n                        assembly {\\n                            mstore(add(add(ret, 36), count), free)\\n                        }\\n                        memcpy(\\n                            state[idx & IDX_VALUE_MASK],\\n                            0,\\n                            ret,\\n                            free + 4,\\n                            argLen\\n                        );\\n                        unchecked {\\n                            free += argLen;\\n                            count += 32;\\n                        }\\n                    }\\n                }\\n            } else {\\n                // Fixed length data\\n                bytes memory stateVar = state[idx & IDX_VALUE_MASK];\\n                if (offset != 0) {\\n                    // Part of dynamic type; write to first free slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), free), mload(add(stateVar, 32)))\\n                    }\\n                    unchecked {\\n                        free += 32;\\n                    }\\n                } else {\\n                    // Write the data to current slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), mload(add(stateVar, 32)))\\n                    }\\n                    unchecked {\\n                        count += 32;\\n                    }\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function writeOutputs(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal pure returns (bytes[] memory) {\\n        uint256 idx = uint8(index);\\n        if (idx == IDX_END_OF_ARGS) return state;\\n\\n        if (idx & IDX_VARIABLE_LENGTH != 0) {\\n            if (idx == IDX_USE_STATE) {\\n                state = abi.decode(output, (bytes[]));\\n            } else {\\n                // Check the first field is 0x20 (because we have only a single return value)\\n                uint256 argPtr;\\n                assembly {\\n                    argPtr := mload(add(output, 32))\\n                }\\n                require(\\n                    argPtr == 32,\\n                    \\\"Only one return value permitted (variable)\\\"\\n                );\\n\\n                assembly {\\n                    // Overwrite the first word of the return data with the length - 32\\n                    mstore(add(output, 32), sub(mload(output), 32))\\n                    // Insert a pointer to the return data, starting at the second word, into state\\n                    mstore(\\n                        add(add(state, 32), mul(and(idx, IDX_VALUE_MASK), 32)),\\n                        add(output, 32)\\n                    )\\n                }\\n            }\\n        } else {\\n            // Single word\\n            require(\\n                output.length == 32,\\n                \\\"Only one return value permitted (static)\\\"\\n            );\\n\\n            state[idx & IDX_VALUE_MASK] = output;\\n        }\\n\\n        return state;\\n    }\\n\\n    function writeTuple(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal view {\\n        uint256 idx = uint256(uint8(index));\\n        if (idx == IDX_END_OF_ARGS) return;\\n\\n        bytes memory entry = state[idx] = new bytes(output.length + 32);\\n        memcpy(output, 0, entry, 32, output.length);\\n        assembly {\\n            let l := mload(output)\\n            mstore(add(entry, 32), l)\\n        }\\n    }\\n\\n    function memcpy(\\n        bytes memory src,\\n        uint256 srcIdx,\\n        bytes memory dest,\\n        uint256 destIdx,\\n        uint256 len\\n    ) internal view {\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    4,\\n                    add(add(src, 32), srcIdx),\\n                    len,\\n                    add(add(dest, 32), destIdx),\\n                    len\\n                )\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9116e8acd07ff992e41fe4ea4e88de1fd6ed866db99d323b936545cfa030b299\",\"license\":\"MIT\"},\"@ensofinance/weiroll/contracts/VM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"./CommandBuilder.sol\\\";\\n\\nabstract contract VM {\\n    using CommandBuilder for bytes[];\\n\\n    uint256 constant FLAG_CT_DELEGATECALL = 0x00;\\n    uint256 constant FLAG_CT_CALL = 0x01;\\n    uint256 constant FLAG_CT_STATICCALL = 0x02;\\n    uint256 constant FLAG_CT_VALUECALL = 0x03;\\n    uint256 constant FLAG_CT_MASK = 0x03;\\n    uint256 constant FLAG_DATA = 0x20;\\n    uint256 constant FLAG_EXTENDED_COMMAND = 0x40;\\n    uint256 constant FLAG_TUPLE_RETURN = 0x80;\\n\\n    uint256 constant SHORT_COMMAND_FILL =\\n        0x000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    error ExecutionFailed(\\n        uint256 command_index,\\n        address target,\\n        string message\\n    );\\n\\n    function _execute(bytes32[] calldata commands, bytes[] memory state)\\n        internal\\n        returns (bytes[] memory)\\n    {\\n        bytes32 command;\\n        uint256 flags;\\n        bytes32 indices;\\n\\n        bool success;\\n        bytes memory outData;\\n\\n        uint256 commandsLength = commands.length;\\n        for (uint256 i; i < commandsLength; i = _uncheckedIncrement(i)) {\\n            command = commands[i];\\n            flags = uint256(uint8(bytes1(command << 32)));\\n\\n            if (flags & FLAG_EXTENDED_COMMAND != 0) {\\n                i = _uncheckedIncrement(i);\\n                indices = commands[i];\\n            } else {\\n                indices = bytes32(uint256(command << 40) | SHORT_COMMAND_FILL);\\n            }\\n\\n            if (flags & FLAG_CT_MASK == FLAG_CT_DELEGATECALL) {\\n                (success, outData) = address(uint160(uint256(command))) // target\\n                    .delegatecall(\\n                        // inputs\\n                        flags & FLAG_DATA == 0\\n                            ? state.buildInputs(\\n                                bytes4(command), // selector\\n                                indices\\n                            )\\n                            : state[\\n                                uint8(bytes1(indices)) &\\n                                CommandBuilder.IDX_VALUE_MASK\\n                            ]\\n                    );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_CALL) {\\n                (success, outData) = address(uint160(uint256(command))).call( // target\\n                    // inputs\\n                    flags & FLAG_DATA == 0\\n                        ? state.buildInputs(\\n                            bytes4(command), // selector\\n                            indices\\n                        )\\n                        : state[\\n                            uint8(bytes1(indices)) &\\n                            CommandBuilder.IDX_VALUE_MASK\\n                        ]\\n                );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_STATICCALL) {\\n                (success, outData) = address(uint160(uint256(command))) // target\\n                    .staticcall(\\n                        // inputs\\n                        flags & FLAG_DATA == 0\\n                            ? state.buildInputs(\\n                                bytes4(command), // selector\\n                                indices\\n                            )\\n                            : state[\\n                                uint8(bytes1(indices)) &\\n                                CommandBuilder.IDX_VALUE_MASK\\n                            ]\\n                    );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_VALUECALL) {\\n                uint256 callEth;\\n                bytes memory v = state[uint8(bytes1(indices))];\\n                assembly {\\n                    callEth := mload(add(v, 0x20))\\n                }\\n                (success, outData) = address(uint160(uint256(command))).call{ // target\\n                    value: callEth\\n                }(\\n                    // inputs\\n                    flags & FLAG_DATA == 0\\n                        ? state.buildInputs(\\n                            bytes4(command), // selector\\n                            indices << 8 // skip value input\\n                        )\\n                        : state[\\n                            uint8(\\n                                bytes1(indices << 8) // first byte after value input\\n                            ) & CommandBuilder.IDX_VALUE_MASK\\n                        ]\\n                );\\n            } else {\\n                revert(\\\"Invalid calltype\\\");\\n            }\\n\\n            if (!success) {\\n                if (outData.length > 0) {\\n                    assembly {\\n                        outData := add(outData, 68)\\n                    }\\n                }\\n                revert ExecutionFailed({\\n                    command_index: flags & FLAG_EXTENDED_COMMAND == 0\\n                        ? i\\n                        : i - 1,\\n                    target: address(uint160(uint256(command))),\\n                    message: outData.length > 0 ? string(outData) : \\\"Unknown\\\"\\n                });\\n            }\\n\\n            if (flags & FLAG_TUPLE_RETURN != 0) {\\n                state.writeTuple(bytes1(command << 88), outData);\\n            } else {\\n                state = state.writeOutputs(bytes1(command << 88), outData);\\n            }\\n        }\\n        return state;\\n    }\\n\\n    function _uncheckedIncrement(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            ++i;\\n        }\\n        return i;\\n    }\\n}\\n\",\"keccak256\":\"0x5b46e72687038c670dd8ae2a35a5082dbaeb64e9b44b446bde03a8ebd75fd046\",\"license\":\"MIT\"},\"contracts/EnsoWallet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {VM} from \\\"@ensofinance/weiroll/contracts/VM.sol\\\";\\n\\ncontract EnsoWallet is VM {\\n    address public caller;\\n    bool public initialized;\\n\\n    // Already initialized\\n    error AlreadyInit();\\n    // Not caller\\n    error NotCaller();\\n    // Invalid address\\n    error InvalidAddress();\\n\\n    function initialize(\\n        address caller_,\\n        bytes32[] calldata commands,\\n        bytes[] calldata state\\n    ) external payable {\\n        if (initialized) revert AlreadyInit();\\n        caller = caller_;\\n        if (commands.length != 0) {\\n            _execute(commands, state);\\n        }\\n    }\\n\\n    function execute(bytes32[] calldata commands, bytes[] calldata state)\\n        external\\n        payable\\n        returns (bytes[] memory returnData)\\n    {\\n        if (msg.sender != caller) revert NotCaller();\\n        returnData = _execute(commands, state);\\n    }\\n\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0x4fe83f88597abfae41c69374f58c32a76dba062726cd6f7565bfa6d135fda4b8\",\"license\":\"MIT\"},\"contracts/EnsoWalletFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"./EnsoWallet.sol\\\";\\nimport {Clones} from \\\"./Libraries/Clones.sol\\\";\\n\\ncontract EnsoWalletFactory {\\n    using Clones for address;\\n\\n    address public immutable ensoWallet;\\n\\n    event Deployed(EnsoWallet instance);\\n\\n    constructor(address EnsoWallet_) {\\n        ensoWallet = EnsoWallet_;\\n    }\\n\\n    function deploy(bytes32[] calldata commands, bytes[] calldata state) public payable returns (EnsoWallet instance) {\\n        instance = EnsoWallet(payable(ensoWallet.cloneDeterministic(msg.sender)));\\n        instance.initialize{value: msg.value}(msg.sender, commands, state);\\n\\n        emit Deployed(instance);\\n    }\\n\\n    function getAddress() public view returns (address payable) {\\n        return payable(ensoWallet.predictDeterministicAddress(msg.sender, address(this)));\\n    }\\n}\\n\",\"keccak256\":\"0xf7ab20cdee15b6cfe24d9b24c38ad226ca0054ba7483c95edb3a3af2d6db4e97\",\"license\":\"MIT\"},\"contracts/Libraries/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n// Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol\\n\\npragma solidity ^0.8.16;\\n\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, address salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        address salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc0acc80bd2a8fff2e725cb51b21d3c8079edff18dbe5d952f7e8e6f7b3608aa6\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161067f38038061067f83398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b6080516105e86100976000396000818160890152818160da015261019101526105e86000f3fe6080604052600436106100345760003560e01c806338cc4831146100395780635548e1cd14610077578063abbea987146100ab575b600080fd5b34801561004557600080fd5b5061004e6100be565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b34801561008357600080fd5b5061004e7f000000000000000000000000000000000000000000000000000000000000000081565b61004e6100b93660046103b9565b610175565b600061017073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633306040517f3d602d80600a3d3981f3363d3d373d3d3d363d730000000000000000000000008152606093841b60148201527f5af43d82803e903d91602b57fd5bf3ff000000000000000000000000000000006028820152921b6038830152604c8201526037808220606c830152605591012090565b905090565b60006101b773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633610285565b90508073ffffffffffffffffffffffffffffffffffffffff166387258e8e3433888888886040518763ffffffff1660e01b81526004016101fb95949392919061046e565b6000604051808303818588803b15801561021457600080fd5b505af1158015610228573d6000803e3d6000fd5b505060405173ffffffffffffffffffffffffffffffffffffffff851681527ff40fcec21964ffb566044d083b4073f29f7f7929110ea19e1b3ebe375d89055e935060200191506102759050565b60405180910390a1949350505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528360601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152826037826000f591505073ffffffffffffffffffffffffffffffffffffffff8116610367576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f455243313136373a2063726561746532206661696c6564000000000000000000604482015260640160405180910390fd5b92915050565b60008083601f84011261037f57600080fd5b50813567ffffffffffffffff81111561039757600080fd5b6020830191508360208260051b85010111156103b257600080fd5b9250929050565b600080600080604085870312156103cf57600080fd5b843567ffffffffffffffff808211156103e757600080fd5b6103f38883890161036d565b9096509450602087013591508082111561040c57600080fd5b506104198782880161036d565b95989497509550505050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b73ffffffffffffffffffffffffffffffffffffffff86168152600060206060818401528560608401527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8611156104c457600080fd5b8560051b808860808601378301838103608090810160408601528101859052600585901b810160a09081019082018760005b888110156105a1577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6085850301835281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18b360301811261055757600080fd5b8a01868101903567ffffffffffffffff81111561057357600080fd5b80360382131561058257600080fd5b61058d868284610425565b9550505091850191908501906001016104f6565b50919b9a505050505050505050505056fea2646970667358221220065cb2adf813913dea56d5a79a470905851497472c461fe63bd9f745260945d864736f6c63430008100033",
  "deployedBytecode": "0x6080604052600436106100345760003560e01c806338cc4831146100395780635548e1cd14610077578063abbea987146100ab575b600080fd5b34801561004557600080fd5b5061004e6100be565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b34801561008357600080fd5b5061004e7f000000000000000000000000000000000000000000000000000000000000000081565b61004e6100b93660046103b9565b610175565b600061017073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633306040517f3d602d80600a3d3981f3363d3d373d3d3d363d730000000000000000000000008152606093841b60148201527f5af43d82803e903d91602b57fd5bf3ff000000000000000000000000000000006028820152921b6038830152604c8201526037808220606c830152605591012090565b905090565b60006101b773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633610285565b90508073ffffffffffffffffffffffffffffffffffffffff166387258e8e3433888888886040518763ffffffff1660e01b81526004016101fb95949392919061046e565b6000604051808303818588803b15801561021457600080fd5b505af1158015610228573d6000803e3d6000fd5b505060405173ffffffffffffffffffffffffffffffffffffffff851681527ff40fcec21964ffb566044d083b4073f29f7f7929110ea19e1b3ebe375d89055e935060200191506102759050565b60405180910390a1949350505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528360601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152826037826000f591505073ffffffffffffffffffffffffffffffffffffffff8116610367576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f455243313136373a2063726561746532206661696c6564000000000000000000604482015260640160405180910390fd5b92915050565b60008083601f84011261037f57600080fd5b50813567ffffffffffffffff81111561039757600080fd5b6020830191508360208260051b85010111156103b257600080fd5b9250929050565b600080600080604085870312156103cf57600080fd5b843567ffffffffffffffff808211156103e757600080fd5b6103f38883890161036d565b9096509450602087013591508082111561040c57600080fd5b506104198782880161036d565b95989497509550505050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b73ffffffffffffffffffffffffffffffffffffffff86168152600060206060818401528560608401527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8611156104c457600080fd5b8560051b808860808601378301838103608090810160408601528101859052600585901b810160a09081019082018760005b888110156105a1577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6085850301835281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18b360301811261055757600080fd5b8a01868101903567ffffffffffffffff81111561057357600080fd5b80360382131561058257600080fd5b61058d868284610425565b9550505091850191908501906001016104f6565b50919b9a505050505050505050505056fea2646970667358221220065cb2adf813913dea56d5a79a470905851497472c461fe63bd9f745260945d864736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
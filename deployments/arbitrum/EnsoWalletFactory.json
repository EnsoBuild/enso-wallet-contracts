{
  "address": "0x62f90bB98851469c24d250066adcFA53147C6866",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "EnsoWallet_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract EnsoWallet",
          "name": "instance",
          "type": "address"
        }
      ],
      "name": "Deployed",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "commands",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes[]",
          "name": "state",
          "type": "bytes[]"
        }
      ],
      "name": "deploy",
      "outputs": [
        {
          "internalType": "contract EnsoWallet",
          "name": "instance",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ensoWallet",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAddress",
      "outputs": [
        {
          "internalType": "address payable",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x79d67d2d48ff1a1c1f150cb530959f91ba642d7bc23c332716b8fd30cdc7ae49",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xf754916D90B109AE8E405FD34064cF6Df23947eb",
    "contractAddress": null,
    "transactionIndex": 1,
    "gasUsed": "1011544",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x25e3ce568c24a9f7f765d68b44e59f24e61f6b5e4ec217ee8233a02e386e2406",
    "transactionHash": "0x79d67d2d48ff1a1c1f150cb530959f91ba642d7bc23c332716b8fd30cdc7ae49",
    "logs": [],
    "blockNumber": 23357401,
    "cumulativeGasUsed": "1011544",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x92e4F6D782C6750fa5084542400fE342e38A1964"
  ],
  "numDeployments": 1,
  "solcInputHash": "523272f74b6a05f4e481276af3e36b7e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"EnsoWallet_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract EnsoWallet\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"commands\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"state\",\"type\":\"bytes[]\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"contract EnsoWallet\",\"name\":\"instance\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensoWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/EnsoWalletFactory.sol\":\"EnsoWalletFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"@ensofinance/weiroll/contracts/CommandBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\nlibrary CommandBuilder {\\n    uint256 constant IDX_VARIABLE_LENGTH = 0x80;\\n    uint256 constant IDX_VALUE_MASK = 0x7f;\\n    uint256 constant IDX_END_OF_ARGS = 0xff;\\n    uint256 constant IDX_USE_STATE = 0xfe;\\n\\n    function buildInputs(\\n        bytes[] memory state,\\n        bytes4 selector,\\n        bytes32 indices\\n    ) internal view returns (bytes memory ret) {\\n        uint256 idx;\\n\\n        uint256 count; // Number of bytes in whole ABI encoded message\\n        uint256 free; // Pointer to first free byte in tail part of message\\n        bytes memory stateData; // Optionally encode the current state if the call requires it\\n\\n        // Determine the length of the encoded data\\n        for (uint256 i; i < 32; ) {\\n            idx = uint8(indices[i]);\\n            if (idx == IDX_END_OF_ARGS) break;\\n\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    if (stateData.length == 0) {\\n                        stateData = abi.encode(state);\\n                    }\\n                    count += stateData.length;\\n                } else {\\n                    // Add the size of the value, rounded up to the next word boundary, plus space for pointer and length\\n                    uint256 arglen = state[idx & IDX_VALUE_MASK].length;\\n                    require(\\n                        arglen % 32 == 0,\\n                        \\\"Dynamic state variables must be a multiple of 32 bytes\\\"\\n                    );\\n                    count += arglen + 32;\\n                }\\n            } else {\\n                require(\\n                    state[idx & IDX_VALUE_MASK].length == 32,\\n                    \\\"Static state variables must be 32 bytes\\\"\\n                );\\n                count += 32;\\n            }\\n            unchecked {\\n                free += 32;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Encode it\\n        ret = new bytes(count + 4);\\n        assembly {\\n            mstore(add(ret, 32), selector)\\n        }\\n        count = 0;\\n        for (uint256 i; i < 32; ) {\\n            idx = uint8(indices[i]);\\n            if (idx == IDX_END_OF_ARGS) break;\\n\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    memcpy(stateData, 32, ret, free + 4, stateData.length - 32);\\n                    free += stateData.length - 32;\\n                } else {\\n                    uint256 arglen = state[idx & IDX_VALUE_MASK].length;\\n\\n                    // Variable length data; put a pointer in the slot and write the data at the end\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    memcpy(\\n                        state[idx & IDX_VALUE_MASK],\\n                        0,\\n                        ret,\\n                        free + 4,\\n                        arglen\\n                    );\\n                    free += arglen;\\n                }\\n            } else {\\n                // Fixed length data; write it directly\\n                bytes memory statevar = state[idx & IDX_VALUE_MASK];\\n                assembly {\\n                    mstore(add(add(ret, 36), count), mload(add(statevar, 32)))\\n                }\\n            }\\n            unchecked {\\n                count += 32;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function writeOutputs(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal pure returns (bytes[] memory) {\\n        uint256 idx = uint8(index);\\n        if (idx == IDX_END_OF_ARGS) return state;\\n\\n        if (idx & IDX_VARIABLE_LENGTH != 0) {\\n            if (idx == IDX_USE_STATE) {\\n                state = abi.decode(output, (bytes[]));\\n            } else {\\n                // Check the first field is 0x20 (because we have only a single return value)\\n                uint256 argptr;\\n                assembly {\\n                    argptr := mload(add(output, 32))\\n                }\\n                require(\\n                    argptr == 32,\\n                    \\\"Only one return value permitted (variable)\\\"\\n                );\\n\\n                assembly {\\n                    // Overwrite the first word of the return data with the length - 32\\n                    mstore(add(output, 32), sub(mload(output), 32))\\n                    // Insert a pointer to the return data, starting at the second word, into state\\n                    mstore(\\n                        add(add(state, 32), mul(and(idx, IDX_VALUE_MASK), 32)),\\n                        add(output, 32)\\n                    )\\n                }\\n            }\\n        } else {\\n            // Single word\\n            require(\\n                output.length == 32,\\n                \\\"Only one return value permitted (static)\\\"\\n            );\\n\\n            state[idx & IDX_VALUE_MASK] = output;\\n        }\\n\\n        return state;\\n    }\\n\\n    function writeTuple(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal view {\\n        uint256 idx = uint256(uint8(index));\\n        if (idx == IDX_END_OF_ARGS) return;\\n\\n        bytes memory entry = state[idx] = new bytes(output.length + 32);\\n        memcpy(output, 0, entry, 32, output.length);\\n        assembly {\\n            let l := mload(output)\\n            mstore(add(entry, 32), l)\\n        }\\n    }\\n\\n    function memcpy(\\n        bytes memory src,\\n        uint256 srcidx,\\n        bytes memory dest,\\n        uint256 destidx,\\n        uint256 len\\n    ) internal view {\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    4,\\n                    add(add(src, 32), srcidx),\\n                    len,\\n                    add(add(dest, 32), destidx),\\n                    len\\n                )\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1bebc8b8ec511e0c62ca6e70b32d9b792ac0e699644f9336529b4f22148ce628\",\"license\":\"MIT\"},\"@ensofinance/weiroll/contracts/VM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\nimport \\\"./CommandBuilder.sol\\\";\\n\\nabstract contract VM {\\n    using CommandBuilder for bytes[];\\n\\n    uint256 constant FLAG_CT_DELEGATECALL = 0x00;\\n    uint256 constant FLAG_CT_CALL = 0x01;\\n    uint256 constant FLAG_CT_STATICCALL = 0x02;\\n    uint256 constant FLAG_CT_VALUECALL = 0x03;\\n    uint256 constant FLAG_CT_MASK = 0x03;\\n    uint256 constant FLAG_TUPLE_RETURN = 0x80;\\n    uint256 constant FLAG_EXTENDED_COMMAND = 0x40;\\n    uint256 constant FLAG_DATA = 0x20;\\n\\n    uint256 constant SHORT_COMMAND_FILL =\\n        0x000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    address immutable self;\\n\\n    error ExecutionFailed(\\n        uint256 command_index,\\n        address target,\\n        string message\\n    );\\n\\n    constructor() {\\n        self = address(this);\\n    }\\n\\n    function _execute(bytes32[] calldata commands, bytes[] memory state)\\n        internal\\n        returns (bytes[] memory)\\n    {\\n        bytes32 command;\\n        uint256 flags;\\n        bytes32 indices;\\n\\n        bool success;\\n        bytes memory outdata;\\n\\n        uint256 commandsLength = commands.length;\\n        for (uint256 i; i < commandsLength; i = _uncheckedIncrement(i)) {\\n            command = commands[i];\\n            flags = uint256(uint8(bytes1(command << 32)));\\n\\n            if (flags & FLAG_EXTENDED_COMMAND != 0) {\\n                i = _uncheckedIncrement(i);\\n                indices = commands[i];\\n            } else {\\n                indices = bytes32(uint256(command << 40) | SHORT_COMMAND_FILL);\\n            }\\n\\n            if (flags & FLAG_CT_MASK == FLAG_CT_DELEGATECALL) {\\n                (success, outdata) = address(uint160(uint256(command))) // target\\n                    .delegatecall(\\n                        // inputs\\n                        flags & FLAG_DATA == 0\\n                            ? state.buildInputs(\\n                                bytes4(command), // selector\\n                                indices\\n                            )\\n                            : state[\\n                                uint8(bytes1(indices)) &\\n                                    CommandBuilder.IDX_VALUE_MASK\\n                            ]\\n                    );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_CALL) {\\n                (success, outdata) = address(uint160(uint256(command))).call( // target\\n                    // inputs\\n                    flags & FLAG_DATA == 0\\n                        ? state.buildInputs(\\n                            bytes4(command), // selector\\n                            indices\\n                        )\\n                        : state[\\n                            uint8(bytes1(indices)) &\\n                                CommandBuilder.IDX_VALUE_MASK\\n                        ]\\n                );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_STATICCALL) {\\n                (success, outdata) = address(uint160(uint256(command))) // target\\n                    .staticcall(\\n                        // inputs\\n                        flags & FLAG_DATA == 0\\n                            ? state.buildInputs(\\n                                bytes4(command), // selector\\n                                indices\\n                            )\\n                            : state[\\n                                uint8(bytes1(indices)) &\\n                                    CommandBuilder.IDX_VALUE_MASK\\n                            ]\\n                    );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_VALUECALL) {\\n                uint256 calleth;\\n                bytes memory v = state[uint8(bytes1(indices))];\\n                assembly {\\n                    calleth := mload(add(v, 0x20))\\n                }\\n                (success, outdata) = address(uint160(uint256(command))).call{ // target\\n                    value: calleth\\n                }(\\n                    // inputs\\n                    flags & FLAG_DATA == 0\\n                        ? state.buildInputs(\\n                            bytes4(command), // selector\\n                            indices << 8 // skip value input\\n                        )\\n                        : state[\\n                            uint8(\\n                                bytes1(indices << 8) // first byte after value input\\n                            ) & CommandBuilder.IDX_VALUE_MASK\\n                        ]\\n                );\\n            } else {\\n                revert(\\\"Invalid calltype\\\");\\n            }\\n\\n            if (!success) {\\n                if (outdata.length > 0) {\\n                    assembly {\\n                        outdata := add(outdata, 68)\\n                    }\\n                }\\n                revert ExecutionFailed({\\n                    command_index: i,\\n                    target: address(uint160(uint256(command))),\\n                    message: outdata.length > 0 ? string(outdata) : \\\"Unknown\\\"\\n                });\\n            }\\n\\n            if (flags & FLAG_TUPLE_RETURN != 0) {\\n                state.writeTuple(bytes1(command << 88), outdata);\\n            } else {\\n                state = state.writeOutputs(bytes1(command << 88), outdata);\\n            }\\n        }\\n        return state;\\n    }\\n\\n    function _uncheckedIncrement(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            ++i;\\n        }\\n        return i;\\n    }\\n}\\n\",\"keccak256\":\"0x4965eb8fdeab8a6cf2ce5fbee6814b1531730b3dd04420f0f52bfa1eaae01200\",\"license\":\"MIT\"},\"contracts/EnsoWallet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {VM} from \\\"@ensofinance/weiroll/contracts/VM.sol\\\";\\n\\ncontract EnsoWallet is VM {\\n    address public caller;\\n    bool public initialized;\\n\\n    // Already initialized\\n    error AlreadyInit();\\n    // Not caller\\n    error NotCaller();\\n    // Invalid address\\n    error InvalidAddress();\\n\\n    function initialize(\\n        address caller_,\\n        bytes32[] calldata commands,\\n        bytes[] calldata state\\n    ) external payable {\\n        if (initialized) revert AlreadyInit();\\n        caller = caller_;\\n        if (commands.length != 0) {\\n            _execute(commands, state);\\n        }\\n    }\\n\\n    function execute(bytes32[] calldata commands, bytes[] calldata state)\\n        external\\n        payable\\n        returns (bytes[] memory returnData)\\n    {\\n        if (msg.sender != caller) revert NotCaller();\\n        returnData = _execute(commands, state);\\n    }\\n\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0xb80a5ae5ded9ec1d2e74e2d69abc0e5f674888ff9ecdb1e2933f720a48b74b1f\",\"license\":\"MIT\"},\"contracts/EnsoWalletFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"./EnsoWallet.sol\\\";\\nimport {Clones} from \\\"./Libraries/Clones.sol\\\";\\n\\ncontract EnsoWalletFactory {\\n    using Clones for address;\\n\\n    address public immutable ensoWallet;\\n\\n    event Deployed(EnsoWallet instance);\\n\\n    constructor(address EnsoWallet_) {\\n        ensoWallet = EnsoWallet_;\\n    }\\n\\n    function deploy(bytes32[] calldata commands, bytes[] calldata state) public payable returns (EnsoWallet instance) {\\n        instance = EnsoWallet(payable(ensoWallet.cloneDeterministic(msg.sender)));\\n        instance.initialize{value: msg.value}(msg.sender, commands, state);\\n\\n        emit Deployed(instance);\\n    }\\n\\n    function getAddress() public view returns (address payable) {\\n        return payable(ensoWallet.predictDeterministicAddress(msg.sender, address(this)));\\n    }\\n}\\n\",\"keccak256\":\"0x94208e9a10a9b6d534961df06d6806cf72c89a2adcaf9e6a58dda6cb5fe0de5d\",\"license\":\"MIT\"},\"contracts/Libraries/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n// Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, address salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        address salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x24935f7394af468793c51805881643eea06f3058ec824b0a30d5af9b7fb244a0\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161067e38038061067e83398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b6080516105e76100976000396000818160890152818160da015261019101526105e76000f3fe6080604052600436106100345760003560e01c806338cc4831146100395780635548e1cd14610077578063abbea987146100ab575b600080fd5b34801561004557600080fd5b5061004e6100be565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b34801561008357600080fd5b5061004e7f000000000000000000000000000000000000000000000000000000000000000081565b61004e6100b93660046103b9565b610175565b600061017073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633306040517f3d602d80600a3d3981f3363d3d373d3d3d363d730000000000000000000000008152606093841b60148201527f5af43d82803e903d91602b57fd5bf3ff000000000000000000000000000000006028820152921b6038830152604c8201526037808220606c830152605591012090565b905090565b60006101b773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633610285565b90508073ffffffffffffffffffffffffffffffffffffffff166387258e8e3433888888886040518763ffffffff1660e01b81526004016101fb95949392919061046e565b6000604051808303818588803b15801561021457600080fd5b505af1158015610228573d6000803e3d6000fd5b505060405173ffffffffffffffffffffffffffffffffffffffff851681527ff40fcec21964ffb566044d083b4073f29f7f7929110ea19e1b3ebe375d89055e935060200191506102759050565b60405180910390a1949350505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528360601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152826037826000f591505073ffffffffffffffffffffffffffffffffffffffff8116610367576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f455243313136373a2063726561746532206661696c6564000000000000000000604482015260640160405180910390fd5b92915050565b60008083601f84011261037f57600080fd5b50813567ffffffffffffffff81111561039757600080fd5b6020830191508360208260051b85010111156103b257600080fd5b9250929050565b600080600080604085870312156103cf57600080fd5b843567ffffffffffffffff808211156103e757600080fd5b6103f38883890161036d565b9096509450602087013591508082111561040c57600080fd5b506104198782880161036d565b95989497509550505050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b73ffffffffffffffffffffffffffffffffffffffff86168152600060206060818401528560608401527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8611156104c457600080fd5b8560051b808860808601378301838103608090810160408601528101859052600585901b810160a09081019082018760005b888110156105a0577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6085850301835281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18b360301811261055757600080fd5b8a01803567ffffffffffffffff81111561057057600080fd5b8036038c131561057f57600080fd5b61058c86828a8501610425565b9550505091850191908501906001016104f6565b50919b9a505050505050505050505056fea264697066735822122078068ab30247bf789ce354463282f3effb573e8c686dc00703c51c903bc594fe64736f6c634300080d0033",
  "deployedBytecode": "0x6080604052600436106100345760003560e01c806338cc4831146100395780635548e1cd14610077578063abbea987146100ab575b600080fd5b34801561004557600080fd5b5061004e6100be565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b34801561008357600080fd5b5061004e7f000000000000000000000000000000000000000000000000000000000000000081565b61004e6100b93660046103b9565b610175565b600061017073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633306040517f3d602d80600a3d3981f3363d3d373d3d3d363d730000000000000000000000008152606093841b60148201527f5af43d82803e903d91602b57fd5bf3ff000000000000000000000000000000006028820152921b6038830152604c8201526037808220606c830152605591012090565b905090565b60006101b773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633610285565b90508073ffffffffffffffffffffffffffffffffffffffff166387258e8e3433888888886040518763ffffffff1660e01b81526004016101fb95949392919061046e565b6000604051808303818588803b15801561021457600080fd5b505af1158015610228573d6000803e3d6000fd5b505060405173ffffffffffffffffffffffffffffffffffffffff851681527ff40fcec21964ffb566044d083b4073f29f7f7929110ea19e1b3ebe375d89055e935060200191506102759050565b60405180910390a1949350505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528360601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152826037826000f591505073ffffffffffffffffffffffffffffffffffffffff8116610367576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f455243313136373a2063726561746532206661696c6564000000000000000000604482015260640160405180910390fd5b92915050565b60008083601f84011261037f57600080fd5b50813567ffffffffffffffff81111561039757600080fd5b6020830191508360208260051b85010111156103b257600080fd5b9250929050565b600080600080604085870312156103cf57600080fd5b843567ffffffffffffffff808211156103e757600080fd5b6103f38883890161036d565b9096509450602087013591508082111561040c57600080fd5b506104198782880161036d565b95989497509550505050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b73ffffffffffffffffffffffffffffffffffffffff86168152600060206060818401528560608401527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8611156104c457600080fd5b8560051b808860808601378301838103608090810160408601528101859052600585901b810160a09081019082018760005b888110156105a0577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6085850301835281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18b360301811261055757600080fd5b8a01803567ffffffffffffffff81111561057057600080fd5b8036038c131561057f57600080fd5b61058c86828a8501610425565b9550505091850191908501906001016104f6565b50919b9a505050505050505050505056fea264697066735822122078068ab30247bf789ce354463282f3effb573e8c686dc00703c51c903bc594fe64736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
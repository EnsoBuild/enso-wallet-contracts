{
  "address": "0x39689981327f549e693dd1CcE71F06898ABa0F0D",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "EnsoWallet_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract EnsoWallet",
          "name": "instance",
          "type": "address"
        }
      ],
      "name": "Deployed",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "commands",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes[]",
          "name": "state",
          "type": "bytes[]"
        }
      ],
      "name": "deploy",
      "outputs": [
        {
          "internalType": "contract EnsoWallet",
          "name": "instance",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ensoWallet",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAddress",
      "outputs": [
        {
          "internalType": "address payable",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x302f0aca93c8c82ccafd262745984bccdf8e8d87e8723911a90f3f14353b81aa",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xf754916D90B109AE8E405FD34064cF6Df23947eb",
    "contractAddress": null,
    "transactionIndex": 1,
    "gasUsed": "1645974",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa2f2374206b3f7a43593433ab97b36fc07ab97006da18adac8bee4e188223df1",
    "transactionHash": "0x302f0aca93c8c82ccafd262745984bccdf8e8d87e8723911a90f3f14353b81aa",
    "logs": [],
    "blockNumber": 38499055,
    "cumulativeGasUsed": "1645974",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x3A859e16b0752a53c9C694B8928FE5F77b6fA6E3"
  ],
  "numDeployments": 3,
  "solcInputHash": "c5bd95db501c40a4c333b1143683ebdd",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"EnsoWallet_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract EnsoWallet\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"commands\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"state\",\"type\":\"bytes[]\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"contract EnsoWallet\",\"name\":\"instance\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensoWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/EnsoWalletFactory.sol\":\"EnsoWalletFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@ensofinance/weiroll/contracts/CommandBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary CommandBuilder {\\n    uint256 constant IDX_VARIABLE_LENGTH = 0x80;\\n    uint256 constant IDX_VALUE_MASK = 0x7f;\\n    uint256 constant IDX_END_OF_ARGS = 0xff;\\n    uint256 constant IDX_USE_STATE = 0xfe;\\n    uint256 constant IDX_ARRAY_START = 0xfd;\\n    uint256 constant IDX_TUPLE_START = 0xfc;\\n    uint256 constant IDX_DYNAMIC_END = 0xfb;\\n\\n    function buildInputs(\\n        bytes[] memory state,\\n        bytes4 selector,\\n        bytes32 indices\\n    ) internal view returns (bytes memory ret) {\\n        uint256 idx; // The current command index\\n        uint256 offsetIdx; // The index of the current free offset\\n\\n        uint256 count; // Number of bytes in whole ABI encoded message\\n        uint256 free; // Pointer to first free byte in tail part of message\\n        uint256[] memory offsets = new uint256[](10); // Optionally store the length of all dynamic types (a command cannot fit more than 10 dynamic types)\\n\\n        bytes memory stateData; // Optionally encode the current state if the call requires it\\n\\n        uint256 indicesLength; // Number of indices\\n\\n        // Determine the length of the encoded data\\n        for (uint256 i; i < 32; ) {\\n            idx = uint8(indices[i]);\\n            if (idx == IDX_END_OF_ARGS) {\\n                indicesLength = i;\\n                break;\\n            }\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    if (stateData.length == 0) {\\n                        stateData = abi.encode(state);\\n                    }\\n                    unchecked {\\n                        count += stateData.length;\\n                    }\\n                } else if (idx == IDX_ARRAY_START) {\\n                    (offsets, offsetIdx, count, i) = setupDynamicArray(state, indices, offsets, offsetIdx, count, i);\\n                } else if (idx == IDX_TUPLE_START) {\\n                    (offsets, offsetIdx, count, i) = setupDynamicTuple(state, indices, offsets, offsetIdx, count, i);\\n                } else {\\n                    count = setupDynamicVariable(state, count, idx);\\n                }\\n            } else {\\n                count = setupStaticVariable(state, count, idx);\\n            }\\n            unchecked {\\n                free += 32;\\n                ++i;\\n            }\\n        }\\n\\n        // Encode it\\n        ret = new bytes(count + 4);\\n        assembly {\\n            mstore(add(ret, 32), selector)\\n        }\\n        count = 0;\\n        offsetIdx = 0;\\n        for (uint256 i; i < indicesLength; ) {\\n            idx = uint8(indices[i]);\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    memcpy(stateData, 32, ret, free + 4, stateData.length - 32);\\n                    unchecked {\\n                        free += stateData.length - 32;\\n                        count += 32;\\n                    }\\n                } else if (idx == IDX_ARRAY_START) {\\n                    // Start of dynamic type, put pointer in current slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    (offsetIdx, free, , i) = encodeDynamicArray(ret, state, indices, offsets, offsetIdx, free, i);\\n                    unchecked {\\n                        count += 32;\\n                    }\\n                } else if (idx == IDX_TUPLE_START) {\\n                    // Start of dynamic type, put pointer in current slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    (offsetIdx, free, , i) = encodeDynamicTuple(ret, state, indices, offsets, offsetIdx, free, i);\\n                    unchecked {\\n                        count += 32;\\n                    }\\n                } else {\\n                    // Variable length data\\n                    uint256 argLen = state[idx & IDX_VALUE_MASK].length;\\n                    // Put a pointer in the current slot and write the data to first free slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    memcpy(\\n                        state[idx & IDX_VALUE_MASK],\\n                        0,\\n                        ret,\\n                        free + 4,\\n                        argLen\\n                    );\\n                    unchecked {\\n                        free += argLen;\\n                        count += 32;\\n                    }\\n                }\\n            } else {\\n                // Fixed length data\\n                bytes memory stateVar = state[idx & IDX_VALUE_MASK];\\n                // Write the data to current slot\\n                assembly {\\n                    mstore(add(add(ret, 36), count), mload(add(stateVar, 32)))\\n                }\\n                unchecked {\\n                    count += 32;\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function setupStaticVariable(\\n        bytes[] memory state,\\n        uint256 count,\\n        uint256 idx\\n    ) internal pure returns (uint256) {\\n        require(\\n            state[idx & IDX_VALUE_MASK].length == 32,\\n            \\\"Static state variables must be 32 bytes\\\"\\n        );\\n        unchecked {\\n            count += 32;\\n        }\\n        return count;\\n    }\\n\\n    function setupDynamicVariable(\\n        bytes[] memory state,\\n        uint256 count,\\n        uint256 idx\\n    ) internal pure returns (uint256) {\\n        // Add the length of the value, rounded up to the next word boundary, plus space for pointer and length\\n        uint256 argLen = state[idx & IDX_VALUE_MASK].length;\\n        require(\\n            argLen % 32 == 0,\\n            \\\"Dynamic state variables must be a multiple of 32 bytes\\\"\\n        );\\n        unchecked {\\n            count += argLen + 32;\\n        }\\n        return count;\\n    }\\n\\n    function setupDynamicArray(\\n        bytes[] memory state,\\n        bytes32 indices,\\n        uint256[] memory offsets,\\n        uint256 offsetIdx,\\n        uint256 count,\\n        uint256 i\\n    ) internal view returns (uint256[] memory, uint256, uint256, uint256) {\\n        // Current idx is IDX_ARRAY_START, next idx will contain the array length\\n        unchecked {\\n            ++i;\\n            count += 32;\\n        }\\n        uint256 idx = uint8(indices[i]);\\n        require(\\n            state[idx & IDX_VALUE_MASK].length == 32,\\n            \\\"Array length must be 32 bytes\\\"\\n        );\\n        return setupDynamicTuple(state, indices, offsets, offsetIdx, count, i);\\n    }\\n\\n    function setupDynamicTuple(\\n        bytes[] memory state,\\n        bytes32 indices,\\n        uint256[] memory offsets,\\n        uint256 offsetIdx,\\n        uint256 count,\\n        uint256 i\\n    ) internal view returns (uint256[] memory, uint256, uint256, uint256) {\\n        uint256 idx;\\n        uint256 offset;\\n        uint256 nextOffsetIdx;\\n        // Progress to first index of the data and progress the next offset idx\\n        unchecked {\\n            ++i;\\n            nextOffsetIdx = offsetIdx + 1;\\n            count += 32;\\n        }\\n        while (i < 32) {\\n            idx = uint8(indices[i]);\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_DYNAMIC_END) {\\n                    offsets[offsetIdx] = offset;\\n                    // Return\\n                    return (offsets, nextOffsetIdx, count, i);\\n                } else if (idx == IDX_ARRAY_START) {\\n                    (offsets, nextOffsetIdx, count, i) = setupDynamicArray(state, indices, offsets, nextOffsetIdx, count, i);\\n                } else if (idx == IDX_TUPLE_START) {\\n                    (offsets, nextOffsetIdx, count, i) = setupDynamicTuple(state, indices, offsets, nextOffsetIdx, count, i);\\n                } else {\\n                    count = setupDynamicVariable(state, count, idx);\\n                }\\n            } else {\\n                count = setupStaticVariable(state, count, idx);\\n            }\\n            unchecked {\\n                offset += 32;\\n                ++i;\\n            }\\n        }\\n        return (offsets, nextOffsetIdx, count, i);\\n    }\\n\\n    function encodeDynamicArray(\\n        bytes memory ret,\\n        bytes[] memory state,\\n        bytes32 indices,\\n        uint256[] memory offsets,\\n        uint256 offsetIdx,\\n        uint256 free,\\n        uint256 i\\n    ) internal view returns (uint256, uint256, uint256, uint256) {\\n        // Progress to array length metadata\\n        unchecked {\\n            ++i;\\n        }\\n        // Encode array length\\n        uint256 idx = uint8(indices[i]);\\n        bytes memory stateVar = state[idx & IDX_VALUE_MASK];\\n        assembly {\\n            mstore(add(add(ret, 36), free), mload(add(stateVar, 32)))\\n        }\\n        unchecked {\\n            free += 32;\\n        }\\n        uint256 length;\\n        (offsetIdx, free, length, i) = encodeDynamicTuple(ret, state, indices, offsets, offsetIdx, free, i);\\n        unchecked {\\n            length += 32; // Increase length to account for array length metadata\\n        }\\n        return (offsetIdx, free, length, i);\\n    }\\n\\n    function encodeDynamicTuple(\\n        bytes memory ret,\\n        bytes[] memory state,\\n        bytes32 indices,\\n        uint256[] memory offsets,\\n        uint256 offsetIdx,\\n        uint256 free,\\n        uint256 i\\n    ) internal view returns (uint256, uint256, uint256, uint256) {\\n        uint256 idx;\\n        uint256 length; // The number of bytes in this tuple\\n        uint256 offset = offsets[offsetIdx]; // The current offset location\\n        uint256 pointer = offset; // The current pointer for dynamic types\\n        unchecked {\\n            offset += free; // Update the offset location\\n            ++offsetIdx; // Progress to next offsetIdx\\n            ++i; // Progress to first index of the data\\n        }\\n        while (i < 32) {\\n            idx = uint8(indices[i]);\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_DYNAMIC_END) {\\n                    return (offsetIdx, offset, length, i);\\n                } else if (idx == IDX_ARRAY_START) {\\n                    // Start of dynamic type, put pointer in current slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), free), pointer)\\n                    }\\n                    uint256 argLen;\\n                    (offsetIdx, offset, argLen, i) = encodeDynamicArray(ret, state, indices, offsets, offsetIdx, offset, i);\\n                    unchecked {\\n                        pointer += argLen;\\n                        length += (argLen + 32); // data + pointer\\n                        free += 32;\\n                    }\\n                } else if (idx == IDX_TUPLE_START) {\\n                    // Start of dynamic type, put pointer in current slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), free), pointer)\\n                    }\\n                    uint256 argLen;\\n                    (offsetIdx, offset, argLen, i) = encodeDynamicTuple(ret, state, indices, offsets, offsetIdx, offset, i);\\n                    unchecked {\\n                        pointer += argLen;\\n                        length += (argLen + 32); // data + pointer\\n                        free += 32;\\n                    }\\n                } else  {\\n                    // Variable length data\\n                    uint256 argLen = state[idx & IDX_VALUE_MASK].length;\\n                    // Put a pointer in the first free slot and write the data to the offset free slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), free), pointer)\\n                    }\\n                    memcpy(\\n                        state[idx & IDX_VALUE_MASK],\\n                        0,\\n                        ret,\\n                        offset + 4,\\n                        argLen\\n                    );\\n                    unchecked {\\n                        offset += argLen;\\n                        pointer += argLen;\\n                        length += (argLen + 32); // data + pointer\\n                        free += 32;\\n                    }\\n                }\\n            } else {\\n                // Fixed length data\\n                bytes memory stateVar = state[idx & IDX_VALUE_MASK];\\n                // Write to first free slot\\n                assembly {\\n                    mstore(add(add(ret, 36), free), mload(add(stateVar, 32)))\\n                }\\n                unchecked {\\n                    length += 32;\\n                    free += 32;\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return (offsetIdx, offset, length, i);\\n    }\\n\\n    function writeOutputs(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal pure returns (bytes[] memory) {\\n        uint256 idx = uint8(index);\\n        if (idx == IDX_END_OF_ARGS) return state;\\n\\n        if (idx & IDX_VARIABLE_LENGTH != 0) {\\n            if (idx == IDX_USE_STATE) {\\n                state = abi.decode(output, (bytes[]));\\n            } else {\\n                // Check the first field is 0x20 (because we have only a single return value)\\n                uint256 argPtr;\\n                assembly {\\n                    argPtr := mload(add(output, 32))\\n                }\\n                require(\\n                    argPtr == 32,\\n                    \\\"Only one return value permitted (variable)\\\"\\n                );\\n\\n                assembly {\\n                    // Overwrite the first word of the return data with the length - 32\\n                    mstore(add(output, 32), sub(mload(output), 32))\\n                    // Insert a pointer to the return data, starting at the second word, into state\\n                    mstore(\\n                        add(add(state, 32), mul(and(idx, IDX_VALUE_MASK), 32)),\\n                        add(output, 32)\\n                    )\\n                }\\n            }\\n        } else {\\n            // Single word\\n            require(\\n                output.length == 32,\\n                \\\"Only one return value permitted (static)\\\"\\n            );\\n\\n            state[idx & IDX_VALUE_MASK] = output;\\n        }\\n\\n        return state;\\n    }\\n\\n    function writeTuple(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal view {\\n        uint256 idx = uint8(index);\\n        if (idx == IDX_END_OF_ARGS) return;\\n\\n        bytes memory entry = state[idx] = new bytes(output.length + 32);\\n        memcpy(output, 0, entry, 32, output.length);\\n        assembly {\\n            let l := mload(output)\\n            mstore(add(entry, 32), l)\\n        }\\n    }\\n\\n    function memcpy(\\n        bytes memory src,\\n        uint256 srcIdx,\\n        bytes memory dest,\\n        uint256 destIdx,\\n        uint256 len\\n    ) internal view {\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    4,\\n                    add(add(src, 32), srcIdx),\\n                    len,\\n                    add(add(dest, 32), destIdx),\\n                    len\\n                )\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x703fbd8a7a4b68f7e240f68a7153c91ae2b8f5517741487a4282a501131f03a8\",\"license\":\"MIT\"},\"@ensofinance/weiroll/contracts/VM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"./CommandBuilder.sol\\\";\\n\\nabstract contract VM {\\n    using CommandBuilder for bytes[];\\n\\n    uint256 constant FLAG_CT_DELEGATECALL = 0x00;\\n    uint256 constant FLAG_CT_CALL = 0x01;\\n    uint256 constant FLAG_CT_STATICCALL = 0x02;\\n    uint256 constant FLAG_CT_VALUECALL = 0x03;\\n    uint256 constant FLAG_CT_MASK = 0x03;\\n    uint256 constant FLAG_DATA = 0x20;\\n    uint256 constant FLAG_EXTENDED_COMMAND = 0x40;\\n    uint256 constant FLAG_TUPLE_RETURN = 0x80;\\n\\n    uint256 constant SHORT_COMMAND_FILL =\\n        0x000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    error ExecutionFailed(\\n        uint256 command_index,\\n        address target,\\n        string message\\n    );\\n\\n    function _execute(bytes32[] calldata commands, bytes[] memory state)\\n        internal\\n        returns (bytes[] memory)\\n    {\\n        bytes32 command;\\n        uint256 flags;\\n        bytes32 indices;\\n\\n        bool success;\\n        bytes memory outData;\\n\\n        uint256 commandsLength = commands.length;\\n        for (uint256 i; i < commandsLength; i = _uncheckedIncrement(i)) {\\n            command = commands[i];\\n            flags = uint256(uint8(bytes1(command << 32)));\\n\\n            if (flags & FLAG_EXTENDED_COMMAND != 0) {\\n                i = _uncheckedIncrement(i);\\n                indices = commands[i];\\n            } else {\\n                indices = bytes32(uint256(command << 40) | SHORT_COMMAND_FILL);\\n            }\\n\\n            if (flags & FLAG_CT_MASK == FLAG_CT_DELEGATECALL) {\\n                (success, outData) = address(uint160(uint256(command))) // target\\n                    .delegatecall(\\n                        // inputs\\n                        flags & FLAG_DATA == 0\\n                            ? state.buildInputs(\\n                                bytes4(command), // selector\\n                                indices\\n                            )\\n                            : state[\\n                                uint8(bytes1(indices)) &\\n                                CommandBuilder.IDX_VALUE_MASK\\n                            ]\\n                    );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_CALL) {\\n                (success, outData) = address(uint160(uint256(command))).call( // target\\n                    // inputs\\n                    flags & FLAG_DATA == 0\\n                        ? state.buildInputs(\\n                            bytes4(command), // selector\\n                            indices\\n                        )\\n                        : state[\\n                            uint8(bytes1(indices)) &\\n                            CommandBuilder.IDX_VALUE_MASK\\n                        ]\\n                );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_STATICCALL) {\\n                (success, outData) = address(uint160(uint256(command))) // target\\n                    .staticcall(\\n                        // inputs\\n                        flags & FLAG_DATA == 0\\n                            ? state.buildInputs(\\n                                bytes4(command), // selector\\n                                indices\\n                            )\\n                            : state[\\n                                uint8(bytes1(indices)) &\\n                                CommandBuilder.IDX_VALUE_MASK\\n                            ]\\n                    );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_VALUECALL) {\\n                uint256 callEth;\\n                bytes memory v = state[uint8(bytes1(indices))];\\n                assembly {\\n                    callEth := mload(add(v, 0x20))\\n                }\\n                (success, outData) = address(uint160(uint256(command))).call{ // target\\n                    value: callEth\\n                }(\\n                    // inputs\\n                    flags & FLAG_DATA == 0\\n                        ? state.buildInputs(\\n                            bytes4(command), // selector\\n                            indices << 8 // skip value input\\n                        )\\n                        : state[\\n                            uint8(\\n                                bytes1(indices << 8) // first byte after value input\\n                            ) & CommandBuilder.IDX_VALUE_MASK\\n                        ]\\n                );\\n            } else {\\n                revert(\\\"Invalid calltype\\\");\\n            }\\n\\n            if (!success) {\\n                if (outData.length > 0) {\\n                    assembly {\\n                        outData := add(outData, 68)\\n                    }\\n                }\\n                revert ExecutionFailed({\\n                    command_index: flags & FLAG_EXTENDED_COMMAND == 0\\n                        ? i\\n                        : i - 1,\\n                    target: address(uint160(uint256(command))),\\n                    message: outData.length > 0 ? string(outData) : \\\"Unknown\\\"\\n                });\\n            }\\n\\n            if (flags & FLAG_TUPLE_RETURN != 0) {\\n                state.writeTuple(bytes1(command << 88), outData);\\n            } else {\\n                state = state.writeOutputs(bytes1(command << 88), outData);\\n            }\\n        }\\n        return state;\\n    }\\n\\n    function _uncheckedIncrement(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            ++i;\\n        }\\n        return i;\\n    }\\n}\\n\",\"keccak256\":\"0x5b46e72687038c670dd8ae2a35a5082dbaeb64e9b44b446bde03a8ebd75fd046\",\"license\":\"MIT\"},\"contracts/EnsoWallet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {VM} from \\\"@ensofinance/weiroll/contracts/VM.sol\\\";\\n\\ncontract EnsoWallet is VM {\\n    address public caller;\\n    bool public initialized;\\n\\n    // Already initialized\\n    error AlreadyInit();\\n    // Not caller\\n    error NotCaller();\\n    // Invalid address\\n    error InvalidAddress();\\n\\n    function initialize(\\n        address caller_,\\n        bytes32[] calldata commands,\\n        bytes[] calldata state\\n    ) external payable {\\n        if (initialized) revert AlreadyInit();\\n        caller = caller_;\\n        if (commands.length != 0) {\\n            _execute(commands, state);\\n        }\\n    }\\n\\n    function execute(bytes32[] calldata commands, bytes[] calldata state)\\n        external\\n        payable\\n        returns (bytes[] memory returnData)\\n    {\\n        if (msg.sender != caller) revert NotCaller();\\n        returnData = _execute(commands, state);\\n    }\\n\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0x4fe83f88597abfae41c69374f58c32a76dba062726cd6f7565bfa6d135fda4b8\",\"license\":\"MIT\"},\"contracts/EnsoWalletFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"./EnsoWallet.sol\\\";\\nimport {Clones} from \\\"./Libraries/Clones.sol\\\";\\n\\ncontract EnsoWalletFactory {\\n    using Clones for address;\\n\\n    address public immutable ensoWallet;\\n\\n    event Deployed(EnsoWallet instance);\\n\\n    constructor(address EnsoWallet_) {\\n        ensoWallet = EnsoWallet_;\\n    }\\n\\n    function deploy(bytes32[] calldata commands, bytes[] calldata state) public payable returns (EnsoWallet instance) {\\n        instance = EnsoWallet(payable(ensoWallet.cloneDeterministic(msg.sender)));\\n        instance.initialize{value: msg.value}(msg.sender, commands, state);\\n\\n        emit Deployed(instance);\\n    }\\n\\n    function getAddress() public view returns (address payable) {\\n        return payable(ensoWallet.predictDeterministicAddress(msg.sender, address(this)));\\n    }\\n}\\n\",\"keccak256\":\"0xf7ab20cdee15b6cfe24d9b24c38ad226ca0054ba7483c95edb3a3af2d6db4e97\",\"license\":\"MIT\"},\"contracts/Libraries/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n// Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol\\n\\npragma solidity ^0.8.16;\\n\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, address salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        address salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc0acc80bd2a8fff2e725cb51b21d3c8079edff18dbe5d952f7e8e6f7b3608aa6\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a03461007757601f6106ec38819003918201601f19168301916001600160401b0383118484101761007c5780849260209460405283398101031261007757516001600160a01b0381168103610077576080526040516106599081610093823960805181818160a6015281816101bf01526102b90152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe60806040526004361015610013575b600080fd5b6000803560e01c90816338cc483114610052575080635548e1cd146100495763abbea9871461004157600080fd5b61000e610214565b5061000e610173565b3461016557807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610165577f3d602d80600a3d3981f3363d3d373d3d3d363d730000000000000000000000006080527f000000000000000000000000000000000000000000000000000000000000000060601b6094527f5af43d82803e903d91602b57fd5bf3ff0000000000000000000000000000000060a8523060601b60b8523360cc52603760802060ec527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8061016073ffffffffffffffffffffffffffffffffffffffff605560b720169073ffffffffffffffffffffffffffffffffffffffff60a09216608052565b016080f35b80fd5b600091031261000e57565b503461000e5760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b9181601f8401121561000e5782359167ffffffffffffffff831161000e576020808501948460051b01011161000e57565b506040807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e5767ffffffffffffffff9060043582811161000e576102629036906004016101e3565b91909260243590811161000e5761027d9036906004016101e3565b73ffffffffffffffffffffffffffffffffffffffff83517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081527f000000000000000000000000000000000000000000000000000000000000000060601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152603733916000f5169384156103fd57843b1561000e576103d39561035a600093865195869485947f87258e8e00000000000000000000000000000000000000000000000000000000865233600487016104dc565b038134875af180156103f0575b6103d7575b50805173ffffffffffffffffffffffffffffffffffffffff831681527ff40fcec21964ffb566044d083b4073f29f7f7929110ea19e1b3ebe375d89055e90602090a15173ffffffffffffffffffffffffffffffffffffffff90911681529081906020820190565b0390f35b806103e46103ea9261045a565b80610168565b3861036c565b6103f8610616565b610367565b606484517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f455243313136373a2063726561746532206661696c65640000000000000000006044820152fd5b67ffffffffffffffff811161046e57604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0938186528686013760008582860101520116010190565b91929073ffffffffffffffffffffffffffffffffffffffff909594951682526020926060848401528160608401527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821161000e5784939295949160051b80916080880137850194608086019060406080828903019101525260a084019360a08360051b82010194846000925b85841061057a575050505050505090565b909192939495967fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6082820301845287357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181121561000e57830186810191903567ffffffffffffffff811161000e57803603831361000e576106058892839260019561049d565b990194019401929594939190610569565b506040513d6000823e3d90fdfea264697066735822122020e038738ccb4e482d0dbdf76a0f9233613bdd9cebf79282938bcfa418594ccf64736f6c63430008100033",
  "deployedBytecode": "0x60806040526004361015610013575b600080fd5b6000803560e01c90816338cc483114610052575080635548e1cd146100495763abbea9871461004157600080fd5b61000e610214565b5061000e610173565b3461016557807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610165577f3d602d80600a3d3981f3363d3d373d3d3d363d730000000000000000000000006080527f000000000000000000000000000000000000000000000000000000000000000060601b6094527f5af43d82803e903d91602b57fd5bf3ff0000000000000000000000000000000060a8523060601b60b8523360cc52603760802060ec527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8061016073ffffffffffffffffffffffffffffffffffffffff605560b720169073ffffffffffffffffffffffffffffffffffffffff60a09216608052565b016080f35b80fd5b600091031261000e57565b503461000e5760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b9181601f8401121561000e5782359167ffffffffffffffff831161000e576020808501948460051b01011161000e57565b506040807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261000e5767ffffffffffffffff9060043582811161000e576102629036906004016101e3565b91909260243590811161000e5761027d9036906004016101e3565b73ffffffffffffffffffffffffffffffffffffffff83517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081527f000000000000000000000000000000000000000000000000000000000000000060601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152603733916000f5169384156103fd57843b1561000e576103d39561035a600093865195869485947f87258e8e00000000000000000000000000000000000000000000000000000000865233600487016104dc565b038134875af180156103f0575b6103d7575b50805173ffffffffffffffffffffffffffffffffffffffff831681527ff40fcec21964ffb566044d083b4073f29f7f7929110ea19e1b3ebe375d89055e90602090a15173ffffffffffffffffffffffffffffffffffffffff90911681529081906020820190565b0390f35b806103e46103ea9261045a565b80610168565b3861036c565b6103f8610616565b610367565b606484517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f455243313136373a2063726561746532206661696c65640000000000000000006044820152fd5b67ffffffffffffffff811161046e57604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0938186528686013760008582860101520116010190565b91929073ffffffffffffffffffffffffffffffffffffffff909594951682526020926060848401528160608401527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821161000e5784939295949160051b80916080880137850194608086019060406080828903019101525260a084019360a08360051b82010194846000925b85841061057a575050505050505090565b909192939495967fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6082820301845287357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181121561000e57830186810191903567ffffffffffffffff811161000e57803603831361000e576106058892839260019561049d565b990194019401929594939190610569565b506040513d6000823e3d90fdfea264697066735822122020e038738ccb4e482d0dbdf76a0f9233613bdd9cebf79282938bcfa418594ccf64736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
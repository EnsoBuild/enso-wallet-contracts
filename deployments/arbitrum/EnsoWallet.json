{
  "address": "0x3A859e16b0752a53c9C694B8928FE5F77b6fA6E3",
  "abi": [
    {
      "inputs": [],
      "name": "AlreadyInit",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "command_index",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "message",
          "type": "string"
        }
      ],
      "name": "ExecutionFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotCaller",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "caller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "commands",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes[]",
          "name": "state",
          "type": "bytes[]"
        }
      ],
      "name": "execute",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "returnData",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller_",
          "type": "address"
        },
        {
          "internalType": "bytes32[]",
          "name": "commands",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes[]",
          "name": "state",
          "type": "bytes[]"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initialized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x5720c778a57ecc70a31d3b63926fd16876cd0caa9ffc5ca6763de56036c15c21",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xf754916D90B109AE8E405FD34064cF6Df23947eb",
    "contractAddress": null,
    "transactionIndex": 2,
    "gasUsed": "4709493",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x63adf0aff62086e8d1b56ed158596b7a07a9b510df34e8703772207c1c7560db",
    "transactionHash": "0x5720c778a57ecc70a31d3b63926fd16876cd0caa9ffc5ca6763de56036c15c21",
    "logs": [],
    "blockNumber": 38499040,
    "cumulativeGasUsed": "5090225",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 3,
  "solcInputHash": "c5bd95db501c40a4c333b1143683ebdd",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AlreadyInit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"command_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"caller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"commands\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"state\",\"type\":\"bytes[]\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"returnData\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller_\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"commands\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"state\",\"type\":\"bytes[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/EnsoWallet.sol\":\"EnsoWallet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@ensofinance/weiroll/contracts/CommandBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary CommandBuilder {\\n    uint256 constant IDX_VARIABLE_LENGTH = 0x80;\\n    uint256 constant IDX_VALUE_MASK = 0x7f;\\n    uint256 constant IDX_END_OF_ARGS = 0xff;\\n    uint256 constant IDX_USE_STATE = 0xfe;\\n    uint256 constant IDX_ARRAY_START = 0xfd;\\n    uint256 constant IDX_TUPLE_START = 0xfc;\\n    uint256 constant IDX_DYNAMIC_END = 0xfb;\\n\\n    function buildInputs(\\n        bytes[] memory state,\\n        bytes4 selector,\\n        bytes32 indices\\n    ) internal view returns (bytes memory ret) {\\n        uint256 idx; // The current command index\\n        uint256 offsetIdx; // The index of the current free offset\\n\\n        uint256 count; // Number of bytes in whole ABI encoded message\\n        uint256 free; // Pointer to first free byte in tail part of message\\n        uint256[] memory offsets = new uint256[](10); // Optionally store the length of all dynamic types (a command cannot fit more than 10 dynamic types)\\n\\n        bytes memory stateData; // Optionally encode the current state if the call requires it\\n\\n        uint256 indicesLength; // Number of indices\\n\\n        // Determine the length of the encoded data\\n        for (uint256 i; i < 32; ) {\\n            idx = uint8(indices[i]);\\n            if (idx == IDX_END_OF_ARGS) {\\n                indicesLength = i;\\n                break;\\n            }\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    if (stateData.length == 0) {\\n                        stateData = abi.encode(state);\\n                    }\\n                    unchecked {\\n                        count += stateData.length;\\n                    }\\n                } else if (idx == IDX_ARRAY_START) {\\n                    (offsets, offsetIdx, count, i) = setupDynamicArray(state, indices, offsets, offsetIdx, count, i);\\n                } else if (idx == IDX_TUPLE_START) {\\n                    (offsets, offsetIdx, count, i) = setupDynamicTuple(state, indices, offsets, offsetIdx, count, i);\\n                } else {\\n                    count = setupDynamicVariable(state, count, idx);\\n                }\\n            } else {\\n                count = setupStaticVariable(state, count, idx);\\n            }\\n            unchecked {\\n                free += 32;\\n                ++i;\\n            }\\n        }\\n\\n        // Encode it\\n        ret = new bytes(count + 4);\\n        assembly {\\n            mstore(add(ret, 32), selector)\\n        }\\n        count = 0;\\n        offsetIdx = 0;\\n        for (uint256 i; i < indicesLength; ) {\\n            idx = uint8(indices[i]);\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    memcpy(stateData, 32, ret, free + 4, stateData.length - 32);\\n                    unchecked {\\n                        free += stateData.length - 32;\\n                        count += 32;\\n                    }\\n                } else if (idx == IDX_ARRAY_START) {\\n                    // Start of dynamic type, put pointer in current slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    (offsetIdx, free, , i) = encodeDynamicArray(ret, state, indices, offsets, offsetIdx, free, i);\\n                    unchecked {\\n                        count += 32;\\n                    }\\n                } else if (idx == IDX_TUPLE_START) {\\n                    // Start of dynamic type, put pointer in current slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    (offsetIdx, free, , i) = encodeDynamicTuple(ret, state, indices, offsets, offsetIdx, free, i);\\n                    unchecked {\\n                        count += 32;\\n                    }\\n                } else {\\n                    // Variable length data\\n                    uint256 argLen = state[idx & IDX_VALUE_MASK].length;\\n                    // Put a pointer in the current slot and write the data to first free slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    memcpy(\\n                        state[idx & IDX_VALUE_MASK],\\n                        0,\\n                        ret,\\n                        free + 4,\\n                        argLen\\n                    );\\n                    unchecked {\\n                        free += argLen;\\n                        count += 32;\\n                    }\\n                }\\n            } else {\\n                // Fixed length data\\n                bytes memory stateVar = state[idx & IDX_VALUE_MASK];\\n                // Write the data to current slot\\n                assembly {\\n                    mstore(add(add(ret, 36), count), mload(add(stateVar, 32)))\\n                }\\n                unchecked {\\n                    count += 32;\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function setupStaticVariable(\\n        bytes[] memory state,\\n        uint256 count,\\n        uint256 idx\\n    ) internal pure returns (uint256) {\\n        require(\\n            state[idx & IDX_VALUE_MASK].length == 32,\\n            \\\"Static state variables must be 32 bytes\\\"\\n        );\\n        unchecked {\\n            count += 32;\\n        }\\n        return count;\\n    }\\n\\n    function setupDynamicVariable(\\n        bytes[] memory state,\\n        uint256 count,\\n        uint256 idx\\n    ) internal pure returns (uint256) {\\n        // Add the length of the value, rounded up to the next word boundary, plus space for pointer and length\\n        uint256 argLen = state[idx & IDX_VALUE_MASK].length;\\n        require(\\n            argLen % 32 == 0,\\n            \\\"Dynamic state variables must be a multiple of 32 bytes\\\"\\n        );\\n        unchecked {\\n            count += argLen + 32;\\n        }\\n        return count;\\n    }\\n\\n    function setupDynamicArray(\\n        bytes[] memory state,\\n        bytes32 indices,\\n        uint256[] memory offsets,\\n        uint256 offsetIdx,\\n        uint256 count,\\n        uint256 i\\n    ) internal view returns (uint256[] memory, uint256, uint256, uint256) {\\n        // Current idx is IDX_ARRAY_START, next idx will contain the array length\\n        unchecked {\\n            ++i;\\n            count += 32;\\n        }\\n        uint256 idx = uint8(indices[i]);\\n        require(\\n            state[idx & IDX_VALUE_MASK].length == 32,\\n            \\\"Array length must be 32 bytes\\\"\\n        );\\n        return setupDynamicTuple(state, indices, offsets, offsetIdx, count, i);\\n    }\\n\\n    function setupDynamicTuple(\\n        bytes[] memory state,\\n        bytes32 indices,\\n        uint256[] memory offsets,\\n        uint256 offsetIdx,\\n        uint256 count,\\n        uint256 i\\n    ) internal view returns (uint256[] memory, uint256, uint256, uint256) {\\n        uint256 idx;\\n        uint256 offset;\\n        uint256 nextOffsetIdx;\\n        // Progress to first index of the data and progress the next offset idx\\n        unchecked {\\n            ++i;\\n            nextOffsetIdx = offsetIdx + 1;\\n            count += 32;\\n        }\\n        while (i < 32) {\\n            idx = uint8(indices[i]);\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_DYNAMIC_END) {\\n                    offsets[offsetIdx] = offset;\\n                    // Return\\n                    return (offsets, nextOffsetIdx, count, i);\\n                } else if (idx == IDX_ARRAY_START) {\\n                    (offsets, nextOffsetIdx, count, i) = setupDynamicArray(state, indices, offsets, nextOffsetIdx, count, i);\\n                } else if (idx == IDX_TUPLE_START) {\\n                    (offsets, nextOffsetIdx, count, i) = setupDynamicTuple(state, indices, offsets, nextOffsetIdx, count, i);\\n                } else {\\n                    count = setupDynamicVariable(state, count, idx);\\n                }\\n            } else {\\n                count = setupStaticVariable(state, count, idx);\\n            }\\n            unchecked {\\n                offset += 32;\\n                ++i;\\n            }\\n        }\\n        return (offsets, nextOffsetIdx, count, i);\\n    }\\n\\n    function encodeDynamicArray(\\n        bytes memory ret,\\n        bytes[] memory state,\\n        bytes32 indices,\\n        uint256[] memory offsets,\\n        uint256 offsetIdx,\\n        uint256 free,\\n        uint256 i\\n    ) internal view returns (uint256, uint256, uint256, uint256) {\\n        // Progress to array length metadata\\n        unchecked {\\n            ++i;\\n        }\\n        // Encode array length\\n        uint256 idx = uint8(indices[i]);\\n        bytes memory stateVar = state[idx & IDX_VALUE_MASK];\\n        assembly {\\n            mstore(add(add(ret, 36), free), mload(add(stateVar, 32)))\\n        }\\n        unchecked {\\n            free += 32;\\n        }\\n        uint256 length;\\n        (offsetIdx, free, length, i) = encodeDynamicTuple(ret, state, indices, offsets, offsetIdx, free, i);\\n        unchecked {\\n            length += 32; // Increase length to account for array length metadata\\n        }\\n        return (offsetIdx, free, length, i);\\n    }\\n\\n    function encodeDynamicTuple(\\n        bytes memory ret,\\n        bytes[] memory state,\\n        bytes32 indices,\\n        uint256[] memory offsets,\\n        uint256 offsetIdx,\\n        uint256 free,\\n        uint256 i\\n    ) internal view returns (uint256, uint256, uint256, uint256) {\\n        uint256 idx;\\n        uint256 length; // The number of bytes in this tuple\\n        uint256 offset = offsets[offsetIdx]; // The current offset location\\n        uint256 pointer = offset; // The current pointer for dynamic types\\n        unchecked {\\n            offset += free; // Update the offset location\\n            ++offsetIdx; // Progress to next offsetIdx\\n            ++i; // Progress to first index of the data\\n        }\\n        while (i < 32) {\\n            idx = uint8(indices[i]);\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_DYNAMIC_END) {\\n                    return (offsetIdx, offset, length, i);\\n                } else if (idx == IDX_ARRAY_START) {\\n                    // Start of dynamic type, put pointer in current slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), free), pointer)\\n                    }\\n                    uint256 argLen;\\n                    (offsetIdx, offset, argLen, i) = encodeDynamicArray(ret, state, indices, offsets, offsetIdx, offset, i);\\n                    unchecked {\\n                        pointer += argLen;\\n                        length += (argLen + 32); // data + pointer\\n                        free += 32;\\n                    }\\n                } else if (idx == IDX_TUPLE_START) {\\n                    // Start of dynamic type, put pointer in current slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), free), pointer)\\n                    }\\n                    uint256 argLen;\\n                    (offsetIdx, offset, argLen, i) = encodeDynamicTuple(ret, state, indices, offsets, offsetIdx, offset, i);\\n                    unchecked {\\n                        pointer += argLen;\\n                        length += (argLen + 32); // data + pointer\\n                        free += 32;\\n                    }\\n                } else  {\\n                    // Variable length data\\n                    uint256 argLen = state[idx & IDX_VALUE_MASK].length;\\n                    // Put a pointer in the first free slot and write the data to the offset free slot\\n                    assembly {\\n                        mstore(add(add(ret, 36), free), pointer)\\n                    }\\n                    memcpy(\\n                        state[idx & IDX_VALUE_MASK],\\n                        0,\\n                        ret,\\n                        offset + 4,\\n                        argLen\\n                    );\\n                    unchecked {\\n                        offset += argLen;\\n                        pointer += argLen;\\n                        length += (argLen + 32); // data + pointer\\n                        free += 32;\\n                    }\\n                }\\n            } else {\\n                // Fixed length data\\n                bytes memory stateVar = state[idx & IDX_VALUE_MASK];\\n                // Write to first free slot\\n                assembly {\\n                    mstore(add(add(ret, 36), free), mload(add(stateVar, 32)))\\n                }\\n                unchecked {\\n                    length += 32;\\n                    free += 32;\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return (offsetIdx, offset, length, i);\\n    }\\n\\n    function writeOutputs(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal pure returns (bytes[] memory) {\\n        uint256 idx = uint8(index);\\n        if (idx == IDX_END_OF_ARGS) return state;\\n\\n        if (idx & IDX_VARIABLE_LENGTH != 0) {\\n            if (idx == IDX_USE_STATE) {\\n                state = abi.decode(output, (bytes[]));\\n            } else {\\n                // Check the first field is 0x20 (because we have only a single return value)\\n                uint256 argPtr;\\n                assembly {\\n                    argPtr := mload(add(output, 32))\\n                }\\n                require(\\n                    argPtr == 32,\\n                    \\\"Only one return value permitted (variable)\\\"\\n                );\\n\\n                assembly {\\n                    // Overwrite the first word of the return data with the length - 32\\n                    mstore(add(output, 32), sub(mload(output), 32))\\n                    // Insert a pointer to the return data, starting at the second word, into state\\n                    mstore(\\n                        add(add(state, 32), mul(and(idx, IDX_VALUE_MASK), 32)),\\n                        add(output, 32)\\n                    )\\n                }\\n            }\\n        } else {\\n            // Single word\\n            require(\\n                output.length == 32,\\n                \\\"Only one return value permitted (static)\\\"\\n            );\\n\\n            state[idx & IDX_VALUE_MASK] = output;\\n        }\\n\\n        return state;\\n    }\\n\\n    function writeTuple(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal view {\\n        uint256 idx = uint8(index);\\n        if (idx == IDX_END_OF_ARGS) return;\\n\\n        bytes memory entry = state[idx] = new bytes(output.length + 32);\\n        memcpy(output, 0, entry, 32, output.length);\\n        assembly {\\n            let l := mload(output)\\n            mstore(add(entry, 32), l)\\n        }\\n    }\\n\\n    function memcpy(\\n        bytes memory src,\\n        uint256 srcIdx,\\n        bytes memory dest,\\n        uint256 destIdx,\\n        uint256 len\\n    ) internal view {\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    4,\\n                    add(add(src, 32), srcIdx),\\n                    len,\\n                    add(add(dest, 32), destIdx),\\n                    len\\n                )\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x703fbd8a7a4b68f7e240f68a7153c91ae2b8f5517741487a4282a501131f03a8\",\"license\":\"MIT\"},\"@ensofinance/weiroll/contracts/VM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"./CommandBuilder.sol\\\";\\n\\nabstract contract VM {\\n    using CommandBuilder for bytes[];\\n\\n    uint256 constant FLAG_CT_DELEGATECALL = 0x00;\\n    uint256 constant FLAG_CT_CALL = 0x01;\\n    uint256 constant FLAG_CT_STATICCALL = 0x02;\\n    uint256 constant FLAG_CT_VALUECALL = 0x03;\\n    uint256 constant FLAG_CT_MASK = 0x03;\\n    uint256 constant FLAG_DATA = 0x20;\\n    uint256 constant FLAG_EXTENDED_COMMAND = 0x40;\\n    uint256 constant FLAG_TUPLE_RETURN = 0x80;\\n\\n    uint256 constant SHORT_COMMAND_FILL =\\n        0x000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    error ExecutionFailed(\\n        uint256 command_index,\\n        address target,\\n        string message\\n    );\\n\\n    function _execute(bytes32[] calldata commands, bytes[] memory state)\\n        internal\\n        returns (bytes[] memory)\\n    {\\n        bytes32 command;\\n        uint256 flags;\\n        bytes32 indices;\\n\\n        bool success;\\n        bytes memory outData;\\n\\n        uint256 commandsLength = commands.length;\\n        for (uint256 i; i < commandsLength; i = _uncheckedIncrement(i)) {\\n            command = commands[i];\\n            flags = uint256(uint8(bytes1(command << 32)));\\n\\n            if (flags & FLAG_EXTENDED_COMMAND != 0) {\\n                i = _uncheckedIncrement(i);\\n                indices = commands[i];\\n            } else {\\n                indices = bytes32(uint256(command << 40) | SHORT_COMMAND_FILL);\\n            }\\n\\n            if (flags & FLAG_CT_MASK == FLAG_CT_DELEGATECALL) {\\n                (success, outData) = address(uint160(uint256(command))) // target\\n                    .delegatecall(\\n                        // inputs\\n                        flags & FLAG_DATA == 0\\n                            ? state.buildInputs(\\n                                bytes4(command), // selector\\n                                indices\\n                            )\\n                            : state[\\n                                uint8(bytes1(indices)) &\\n                                CommandBuilder.IDX_VALUE_MASK\\n                            ]\\n                    );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_CALL) {\\n                (success, outData) = address(uint160(uint256(command))).call( // target\\n                    // inputs\\n                    flags & FLAG_DATA == 0\\n                        ? state.buildInputs(\\n                            bytes4(command), // selector\\n                            indices\\n                        )\\n                        : state[\\n                            uint8(bytes1(indices)) &\\n                            CommandBuilder.IDX_VALUE_MASK\\n                        ]\\n                );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_STATICCALL) {\\n                (success, outData) = address(uint160(uint256(command))) // target\\n                    .staticcall(\\n                        // inputs\\n                        flags & FLAG_DATA == 0\\n                            ? state.buildInputs(\\n                                bytes4(command), // selector\\n                                indices\\n                            )\\n                            : state[\\n                                uint8(bytes1(indices)) &\\n                                CommandBuilder.IDX_VALUE_MASK\\n                            ]\\n                    );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_VALUECALL) {\\n                uint256 callEth;\\n                bytes memory v = state[uint8(bytes1(indices))];\\n                assembly {\\n                    callEth := mload(add(v, 0x20))\\n                }\\n                (success, outData) = address(uint160(uint256(command))).call{ // target\\n                    value: callEth\\n                }(\\n                    // inputs\\n                    flags & FLAG_DATA == 0\\n                        ? state.buildInputs(\\n                            bytes4(command), // selector\\n                            indices << 8 // skip value input\\n                        )\\n                        : state[\\n                            uint8(\\n                                bytes1(indices << 8) // first byte after value input\\n                            ) & CommandBuilder.IDX_VALUE_MASK\\n                        ]\\n                );\\n            } else {\\n                revert(\\\"Invalid calltype\\\");\\n            }\\n\\n            if (!success) {\\n                if (outData.length > 0) {\\n                    assembly {\\n                        outData := add(outData, 68)\\n                    }\\n                }\\n                revert ExecutionFailed({\\n                    command_index: flags & FLAG_EXTENDED_COMMAND == 0\\n                        ? i\\n                        : i - 1,\\n                    target: address(uint160(uint256(command))),\\n                    message: outData.length > 0 ? string(outData) : \\\"Unknown\\\"\\n                });\\n            }\\n\\n            if (flags & FLAG_TUPLE_RETURN != 0) {\\n                state.writeTuple(bytes1(command << 88), outData);\\n            } else {\\n                state = state.writeOutputs(bytes1(command << 88), outData);\\n            }\\n        }\\n        return state;\\n    }\\n\\n    function _uncheckedIncrement(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            ++i;\\n        }\\n        return i;\\n    }\\n}\\n\",\"keccak256\":\"0x5b46e72687038c670dd8ae2a35a5082dbaeb64e9b44b446bde03a8ebd75fd046\",\"license\":\"MIT\"},\"contracts/EnsoWallet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {VM} from \\\"@ensofinance/weiroll/contracts/VM.sol\\\";\\n\\ncontract EnsoWallet is VM {\\n    address public caller;\\n    bool public initialized;\\n\\n    // Already initialized\\n    error AlreadyInit();\\n    // Not caller\\n    error NotCaller();\\n    // Invalid address\\n    error InvalidAddress();\\n\\n    function initialize(\\n        address caller_,\\n        bytes32[] calldata commands,\\n        bytes[] calldata state\\n    ) external payable {\\n        if (initialized) revert AlreadyInit();\\n        caller = caller_;\\n        if (commands.length != 0) {\\n            _execute(commands, state);\\n        }\\n    }\\n\\n    function execute(bytes32[] calldata commands, bytes[] calldata state)\\n        external\\n        payable\\n        returns (bytes[] memory returnData)\\n    {\\n        if (msg.sender != caller) revert NotCaller();\\n        returnData = _execute(commands, state);\\n    }\\n\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0x4fe83f88597abfae41c69374f58c32a76dba062726cd6f7565bfa6d135fda4b8\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60808060405234610016576116da908161001c8239f35b600080fdfe6080604052600436101561001b575b361561001957600080fd5b005b6000803560e01c908163158ef93e1461006e5750806387258e8e14610065578063de792d5f1461005c5763fc9c8d390361000e576100576103c9565b61000e565b506100576102f5565b506100576100e8565b346100af57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100af5760ff905460a01c16151560805260206080f35b80fd5b9181601f840112156100e35782359167ffffffffffffffff83116100e3576020808501948460051b0101116100e357565b600080fd5b5060607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e35760043573ffffffffffffffffffffffffffffffffffffffff811681036100e35767ffffffffffffffff6024358181116100e3576101549036906004016100b2565b90916044359081116100e35761016e9036906004016100b2565b909361018060005460ff9060a01c1690565b6101e5576101c99073ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff00000000000000000000000000000000000000006000541617600055565b816101d057005b610019936101df91369161050a565b9161076e565b60046040517fef34ca5c000000000000000000000000000000000000000000000000000000008152fd5b60005b8381106102225750506000910152565b8181015183820152602001610212565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f60209361026e8151809281875287808801910161020f565b0116010190565b602080820190808352835180925260408301928160408460051b8301019501936000915b8483106102a95750505050505090565b90919293949584806102e5837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc086600196030187528a51610232565b9801930193019194939290610299565b5060407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e35767ffffffffffffffff6004358181116100e3576103419036906004016100b2565b90916024359081116100e35761035b9036906004016100b2565b92909173ffffffffffffffffffffffffffffffffffffffff60005416330361039f576101df61038f9361039b95369161050a565b60405191829182610275565b0390f35b60046040517f16c618d8000000000000000000000000000000000000000000000000000000008152fd5b50346100e35760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e357602073ffffffffffffffffffffffffffffffffffffffff60005416604051908152f35b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761048d57604052565b61049561041c565b604052565b60209067ffffffffffffffff81116104b4575b60051b0190565b6104bc61041c565b6104ad565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f60209267ffffffffffffffff81116104fd575b01160190565b61050561041c565b6104f7565b929190926105178461049a565b916040946105278651948561044c565b839581855260208095019160051b8401938385116100e35780925b8584106105525750505050505050565b833567ffffffffffffffff81116100e357820185601f820112156100e35780359161057c836104c1565b6105888651918261044c565b838152878a85850101116100e35760008a858196828097018386013783010152815201930192610542565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b91908110156105f35760051b0190565b6104bc6105b3565b6020918151811015610610575b60051b010190565b6106186105b3565b610608565b3d15610648573d9061062e826104c1565b9161063c604051938461044c565b82523d6000602084013e565b606090565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82019182116106aa57565b6106b261064d565b565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe082019182116106aa57565b604051906040820182811067ffffffffffffffff82111761072c575b604052600782527f556e6b6e6f776e000000000000000000000000000000000000000000000000006020830152565b61073461041c565b6106fd565b73ffffffffffffffffffffffffffffffffffffffff61076b949360609383521660208201528160408201520190610232565b90565b9060005b81811061077f5750505090565b61078a8183856105e3565b604091903560d881901c838116159283610b5a57600101936107ad8587896105e3565b355b60038381168061094e57505060008091602090818616158314610937576107f9907fffffffff0000000000000000000000000000000000000000000000000000000088168d610c19565b905b8151910173ffffffffffffffffffffffffffffffffffffffff87165af49361082161061d565b945b156108a55750506080161561086b57600192917fff000000000000000000000000000000000000000000000000000000000000006108659260581b1687611624565b01610772565b90600192957fff0000000000000000000000000000000000000000000000000000000000000061089f9360581b1690611578565b93610865565b61090b9250938573ffffffffffffffffffffffffffffffffffffffff95825161092d575b1561091e57905b80511561090f57915b519485947fef3dcb2f000000000000000000000000000000000000000000000000000000008652169060048501610739565b0390fd5b506109186106e1565b916108d9565b6109279061067d565b906108d0565b91604401916108c9565b607f6109479160f81c168c6105fb565b51906107fb565b600181036109dc575050600080916020908186161583146109c557610996907fffffffff0000000000000000000000000000000000000000000000000000000088168d610c19565b905b815191018273ffffffffffffffffffffffffffffffffffffffff88165af1936109bf61061d565b94610823565b607f6109d59160f81c168c6105fb565b5190610998565b60028103610a6357505060008091602090818616158314610a4c57610a24907fffffffff0000000000000000000000000000000000000000000000000000000088168d610c19565b905b8151910173ffffffffffffffffffffffffffffffffffffffff87165afa936109bf61061d565b607f610a5c9160f81c168c6105fb565b5190610a26565b03610afc576000809160209081610a7e8d8360f81c906105fb565b51015190828716158414610ae557610abc9060081b7fffffffff0000000000000000000000000000000000000000000000000000000089168e610c19565b915b825192019073ffffffffffffffffffffffffffffffffffffffff88165af1936109bf61061d565b607f610af59160f01c168d6105fb565b5191610abe565b50517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f496e76616c69642063616c6c74797065000000000000000000000000000000006044820152606490fd5b9379ffffffffffffffffffffffffffffffffffffffffffffffffffff8360281b176107af565b60405190610160820182811067ffffffffffffffff821117610baf575b604052600a8252610140366020840137565b610bb761041c565b610b9d565b90600482018092116106aa57565b90610bd4826104c1565b610be1604051918261044c565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0610c0f82946104c1565b0190602036910137565b929192600090818291610c2a610b80565b916060928596865b60209081891015610ec5578b891a60ff8114610d34576080811615610d265760fe8103610cc25750865115610c75575b90600191875101975b0197019695610c32565b9550600190604051610cb981610c8d89858301610275565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810183528261044c565b96909150610c62565b92989197949193909260fd8103610cf35750916001949391610ce5938d8861101f565b989294919790979493610c6b565b60fc8103610d0d5750916001949391610ce5938d886110ca565b610d2090600193969992959a9488610f7c565b97610c6b565b610d20906001939288610eda565b5097985090969194939250610d5291610d4d9150610bbc565b610bca565b97602095868a0152600093849185965b898810610d755750505050505050505050565b889081891015610eb8575b8c838a1a6080811615610e935760fe8103610df1575081610de1826001959460248d7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe096010152610dd083610bbc565b610dda8c516106b4565b918c611692565b885101019701975b019695610d62565b929895919260fd8103610e2757509160019991858589868560248c610e189a0101526111c7565b90509891979097940197610de9565b60fc8103610e4957509160019991858589868560248c610e189a010152611218565b92610e8a87602493610e798b859b9e979b610e6a607f60019b1680936105fb565b5151978895850101528c6105fb565b5190610e8485610bbc565b91611680565b01970197610de9565b9060248a85610eaa607f600198979e96168c6105fb565b510151920101520197610de9565b610ec06105b3565b610d80565b9050610d4d919750610d529295949350610bbc565b610eeb90607f6020939416906105fb565b515103610ef85760200190565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f537461746963207374617465207661726961626c6573206d757374206265203360448201527f32206279746573000000000000000000000000000000000000000000000000006064820152fd5b607f610f8a929316906105fb565b5151601f8116610f9b570160200190565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603660248201527f44796e616d6963207374617465207661726961626c6573206d7573742062652060448201527f61206d756c7469706c65206f66203332206279746573000000000000000000006064820152fd5b92919093946001019360208510156110bd575b6020611043607f83881a16866105fb565b51510361105f5760206110579601936110ca565b929391929091565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4172726179206c656e677468206d7573742062652033322062797465730000006044820152fd5b6110c56105b3565b611032565b9493909592600091600180960195808301986020809301985b8389106110f65750505050505093929190565b81891a60808116156111b45760fb810361112057505050505061111990836105fb565b5293929190565b9a849b978860fd869d949697999a9c959c146000146111605750906111489392918b8661101f565b9b929b9a919a96909a9b975b019501979092916110e3565b60fc9193959798508092949650146000146111985750928492611188928b958b8e99986110ca565b9b929b9a919a96909a9b97611154565b9a6111ae81939c87958d9799989d949a9d610f7c565b9a611154565b936111ae849582949b989c849694610eda565b93929190602060016111ff9801968188101561120b575b816111ee607f868b1a16856105fb565b510151602482890101520194611218565b92939192602090910191565b6112136105b3565b6111de565b949095929196939660009661122d89856105fb565b51906001808584019b019601975b602095868a101561138457848a1a60808116156113555760fb810361126857505050505050505093929190565b9b8498889d958660fd8a9f9b989e9596979a999e146000146112bc5750602486979861129b9697010152848c89886111c7565b919c9781019095019a91979094019501926001905b0197929390949161123b565b92949650509193955060fc81146000146113045750916112eb918594938960248f988f010152848c8988611218565b919c9781019095019a91979094019501926001906112b0565b9b8860248d83949b9f956113478a61133c8d607f60019b9e9d9c9e169061132b82826105fb565b5151988998899889960101526105fb565b518b610e8485610bbc565b019e019801019a01936112b0565b96869b81929497602483611373999e99607f6001989a9d168c6105fb565b5101519188010152019a01936112b0565b5050505050505093929190565b1561139857565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f4f6e6c79206f6e652072657475726e2076616c7565207065726d69747465642060448201527f28737461746963290000000000000000000000000000000000000000000000006064820152fd5b1561142357565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f4f6e6c79206f6e652072657475726e2076616c7565207065726d69747465642060448201527f287661726961626c6529000000000000000000000000000000000000000000006064820152fd5b60209081818403126100e357805167ffffffffffffffff918282116100e357019083601f830112156100e35781516114de8161049a565b946040926114ee8451978861044c565b828752858088019360051b860101948286116100e357868101935b86851061151b57505050505050505090565b84518381116100e35782019084603f830112156100e3578882015190611540826104c1565b61154c8951918261044c565b828152868984860101116100e35761156d8b949385948b868501910161020f565b815201940193611509565b91908060f81c60ff811461161e5760808116156115f15760fe036115ab575061076b9150602080825183010191016114a7565b610fe06020917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0838501946115e28587511461141c565b5101845260f31c168301015290565b829150607f90611607602061161a955114611391565b169061161382856105fb565b52826105fb565b5090565b50505090565b9060f81c9060ff821461167b5760209161165c9161164c855185810180911161167357610bca565b61165683836105fb565b526105fb565b51918051604084018184840160045afa5051910152565b610d4d61064d565b505050565b916020809185930101920160045afa50565b910160200190829060400160045afa5056fea26469706673582212202d16beb5a60d0239735f2ab06959bf3b6baecba90639ee8fe0fe0ae82c084a4964736f6c63430008100033",
  "deployedBytecode": "0x6080604052600436101561001b575b361561001957600080fd5b005b6000803560e01c908163158ef93e1461006e5750806387258e8e14610065578063de792d5f1461005c5763fc9c8d390361000e576100576103c9565b61000e565b506100576102f5565b506100576100e8565b346100af57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100af5760ff905460a01c16151560805260206080f35b80fd5b9181601f840112156100e35782359167ffffffffffffffff83116100e3576020808501948460051b0101116100e357565b600080fd5b5060607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e35760043573ffffffffffffffffffffffffffffffffffffffff811681036100e35767ffffffffffffffff6024358181116100e3576101549036906004016100b2565b90916044359081116100e35761016e9036906004016100b2565b909361018060005460ff9060a01c1690565b6101e5576101c99073ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff00000000000000000000000000000000000000006000541617600055565b816101d057005b610019936101df91369161050a565b9161076e565b60046040517fef34ca5c000000000000000000000000000000000000000000000000000000008152fd5b60005b8381106102225750506000910152565b8181015183820152602001610212565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f60209361026e8151809281875287808801910161020f565b0116010190565b602080820190808352835180925260408301928160408460051b8301019501936000915b8483106102a95750505050505090565b90919293949584806102e5837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc086600196030187528a51610232565b9801930193019194939290610299565b5060407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e35767ffffffffffffffff6004358181116100e3576103419036906004016100b2565b90916024359081116100e35761035b9036906004016100b2565b92909173ffffffffffffffffffffffffffffffffffffffff60005416330361039f576101df61038f9361039b95369161050a565b60405191829182610275565b0390f35b60046040517f16c618d8000000000000000000000000000000000000000000000000000000008152fd5b50346100e35760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e357602073ffffffffffffffffffffffffffffffffffffffff60005416604051908152f35b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761048d57604052565b61049561041c565b604052565b60209067ffffffffffffffff81116104b4575b60051b0190565b6104bc61041c565b6104ad565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f60209267ffffffffffffffff81116104fd575b01160190565b61050561041c565b6104f7565b929190926105178461049a565b916040946105278651948561044c565b839581855260208095019160051b8401938385116100e35780925b8584106105525750505050505050565b833567ffffffffffffffff81116100e357820185601f820112156100e35780359161057c836104c1565b6105888651918261044c565b838152878a85850101116100e35760008a858196828097018386013783010152815201930192610542565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b91908110156105f35760051b0190565b6104bc6105b3565b6020918151811015610610575b60051b010190565b6106186105b3565b610608565b3d15610648573d9061062e826104c1565b9161063c604051938461044c565b82523d6000602084013e565b606090565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82019182116106aa57565b6106b261064d565b565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe082019182116106aa57565b604051906040820182811067ffffffffffffffff82111761072c575b604052600782527f556e6b6e6f776e000000000000000000000000000000000000000000000000006020830152565b61073461041c565b6106fd565b73ffffffffffffffffffffffffffffffffffffffff61076b949360609383521660208201528160408201520190610232565b90565b9060005b81811061077f5750505090565b61078a8183856105e3565b604091903560d881901c838116159283610b5a57600101936107ad8587896105e3565b355b60038381168061094e57505060008091602090818616158314610937576107f9907fffffffff0000000000000000000000000000000000000000000000000000000088168d610c19565b905b8151910173ffffffffffffffffffffffffffffffffffffffff87165af49361082161061d565b945b156108a55750506080161561086b57600192917fff000000000000000000000000000000000000000000000000000000000000006108659260581b1687611624565b01610772565b90600192957fff0000000000000000000000000000000000000000000000000000000000000061089f9360581b1690611578565b93610865565b61090b9250938573ffffffffffffffffffffffffffffffffffffffff95825161092d575b1561091e57905b80511561090f57915b519485947fef3dcb2f000000000000000000000000000000000000000000000000000000008652169060048501610739565b0390fd5b506109186106e1565b916108d9565b6109279061067d565b906108d0565b91604401916108c9565b607f6109479160f81c168c6105fb565b51906107fb565b600181036109dc575050600080916020908186161583146109c557610996907fffffffff0000000000000000000000000000000000000000000000000000000088168d610c19565b905b815191018273ffffffffffffffffffffffffffffffffffffffff88165af1936109bf61061d565b94610823565b607f6109d59160f81c168c6105fb565b5190610998565b60028103610a6357505060008091602090818616158314610a4c57610a24907fffffffff0000000000000000000000000000000000000000000000000000000088168d610c19565b905b8151910173ffffffffffffffffffffffffffffffffffffffff87165afa936109bf61061d565b607f610a5c9160f81c168c6105fb565b5190610a26565b03610afc576000809160209081610a7e8d8360f81c906105fb565b51015190828716158414610ae557610abc9060081b7fffffffff0000000000000000000000000000000000000000000000000000000089168e610c19565b915b825192019073ffffffffffffffffffffffffffffffffffffffff88165af1936109bf61061d565b607f610af59160f01c168d6105fb565b5191610abe565b50517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f496e76616c69642063616c6c74797065000000000000000000000000000000006044820152606490fd5b9379ffffffffffffffffffffffffffffffffffffffffffffffffffff8360281b176107af565b60405190610160820182811067ffffffffffffffff821117610baf575b604052600a8252610140366020840137565b610bb761041c565b610b9d565b90600482018092116106aa57565b90610bd4826104c1565b610be1604051918261044c565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0610c0f82946104c1565b0190602036910137565b929192600090818291610c2a610b80565b916060928596865b60209081891015610ec5578b891a60ff8114610d34576080811615610d265760fe8103610cc25750865115610c75575b90600191875101975b0197019695610c32565b9550600190604051610cb981610c8d89858301610275565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810183528261044c565b96909150610c62565b92989197949193909260fd8103610cf35750916001949391610ce5938d8861101f565b989294919790979493610c6b565b60fc8103610d0d5750916001949391610ce5938d886110ca565b610d2090600193969992959a9488610f7c565b97610c6b565b610d20906001939288610eda565b5097985090969194939250610d5291610d4d9150610bbc565b610bca565b97602095868a0152600093849185965b898810610d755750505050505050505050565b889081891015610eb8575b8c838a1a6080811615610e935760fe8103610df1575081610de1826001959460248d7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe096010152610dd083610bbc565b610dda8c516106b4565b918c611692565b885101019701975b019695610d62565b929895919260fd8103610e2757509160019991858589868560248c610e189a0101526111c7565b90509891979097940197610de9565b60fc8103610e4957509160019991858589868560248c610e189a010152611218565b92610e8a87602493610e798b859b9e979b610e6a607f60019b1680936105fb565b5151978895850101528c6105fb565b5190610e8485610bbc565b91611680565b01970197610de9565b9060248a85610eaa607f600198979e96168c6105fb565b510151920101520197610de9565b610ec06105b3565b610d80565b9050610d4d919750610d529295949350610bbc565b610eeb90607f6020939416906105fb565b515103610ef85760200190565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f537461746963207374617465207661726961626c6573206d757374206265203360448201527f32206279746573000000000000000000000000000000000000000000000000006064820152fd5b607f610f8a929316906105fb565b5151601f8116610f9b570160200190565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603660248201527f44796e616d6963207374617465207661726961626c6573206d7573742062652060448201527f61206d756c7469706c65206f66203332206279746573000000000000000000006064820152fd5b92919093946001019360208510156110bd575b6020611043607f83881a16866105fb565b51510361105f5760206110579601936110ca565b929391929091565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4172726179206c656e677468206d7573742062652033322062797465730000006044820152fd5b6110c56105b3565b611032565b9493909592600091600180960195808301986020809301985b8389106110f65750505050505093929190565b81891a60808116156111b45760fb810361112057505050505061111990836105fb565b5293929190565b9a849b978860fd869d949697999a9c959c146000146111605750906111489392918b8661101f565b9b929b9a919a96909a9b975b019501979092916110e3565b60fc9193959798508092949650146000146111985750928492611188928b958b8e99986110ca565b9b929b9a919a96909a9b97611154565b9a6111ae81939c87958d9799989d949a9d610f7c565b9a611154565b936111ae849582949b989c849694610eda565b93929190602060016111ff9801968188101561120b575b816111ee607f868b1a16856105fb565b510151602482890101520194611218565b92939192602090910191565b6112136105b3565b6111de565b949095929196939660009661122d89856105fb565b51906001808584019b019601975b602095868a101561138457848a1a60808116156113555760fb810361126857505050505050505093929190565b9b8498889d958660fd8a9f9b989e9596979a999e146000146112bc5750602486979861129b9697010152848c89886111c7565b919c9781019095019a91979094019501926001905b0197929390949161123b565b92949650509193955060fc81146000146113045750916112eb918594938960248f988f010152848c8988611218565b919c9781019095019a91979094019501926001906112b0565b9b8860248d83949b9f956113478a61133c8d607f60019b9e9d9c9e169061132b82826105fb565b5151988998899889960101526105fb565b518b610e8485610bbc565b019e019801019a01936112b0565b96869b81929497602483611373999e99607f6001989a9d168c6105fb565b5101519188010152019a01936112b0565b5050505050505093929190565b1561139857565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f4f6e6c79206f6e652072657475726e2076616c7565207065726d69747465642060448201527f28737461746963290000000000000000000000000000000000000000000000006064820152fd5b1561142357565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f4f6e6c79206f6e652072657475726e2076616c7565207065726d69747465642060448201527f287661726961626c6529000000000000000000000000000000000000000000006064820152fd5b60209081818403126100e357805167ffffffffffffffff918282116100e357019083601f830112156100e35781516114de8161049a565b946040926114ee8451978861044c565b828752858088019360051b860101948286116100e357868101935b86851061151b57505050505050505090565b84518381116100e35782019084603f830112156100e3578882015190611540826104c1565b61154c8951918261044c565b828152868984860101116100e35761156d8b949385948b868501910161020f565b815201940193611509565b91908060f81c60ff811461161e5760808116156115f15760fe036115ab575061076b9150602080825183010191016114a7565b610fe06020917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0838501946115e28587511461141c565b5101845260f31c168301015290565b829150607f90611607602061161a955114611391565b169061161382856105fb565b52826105fb565b5090565b50505090565b9060f81c9060ff821461167b5760209161165c9161164c855185810180911161167357610bca565b61165683836105fb565b526105fb565b51918051604084018184840160045afa5051910152565b610d4d61064d565b505050565b916020809185930101920160045afa50565b910160200190829060400160045afa5056fea26469706673582212202d16beb5a60d0239735f2ab06959bf3b6baecba90639ee8fe0fe0ae82c084a4964736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1609,
        "contract": "contracts/EnsoWallet.sol:EnsoWallet",
        "label": "caller",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 1611,
        "contract": "contracts/EnsoWallet.sol:EnsoWallet",
        "label": "initialized",
        "offset": 20,
        "slot": "0",
        "type": "t_bool"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      }
    }
  }
}
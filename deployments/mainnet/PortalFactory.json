{
  "address": "0x66BB4da2B9191240483a97D01A97e4d95d602F47",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "portal_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract Portal",
          "name": "instance",
          "type": "address"
        }
      ],
      "name": "Deployed",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "commands",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes[]",
          "name": "state",
          "type": "bytes[]"
        }
      ],
      "name": "deploy",
      "outputs": [
        {
          "internalType": "contract Portal",
          "name": "instance",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAddress",
      "outputs": [
        {
          "internalType": "address payable",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "portalImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x67b37ba97d266f13d372a92592eb1de090ed33a61a6a50dea4f8bb6c881b9a2e",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xf754916D90B109AE8E405FD34064cF6Df23947eb",
    "contractAddress": null,
    "transactionIndex": 127,
    "gasUsed": "380653",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5f0ec7944e4da83b01a64e5cb4267869780ab81feed919b2ff870eacc8465fea",
    "transactionHash": "0x67b37ba97d266f13d372a92592eb1de090ed33a61a6a50dea4f8bb6c881b9a2e",
    "logs": [],
    "blockNumber": 15100859,
    "cumulativeGasUsed": "16017025",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x6bb52BE538A1E5668a9c45626EDF2C590e86CA76"
  ],
  "numDeployments": 1,
  "solcInputHash": "391e1a666fcdfbf504cfbe92f13b98de",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"portal_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract Portal\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"commands\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"state\",\"type\":\"bytes[]\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"contract Portal\",\"name\":\"instance\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"portalImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/PortalFactory.sol\":\"PortalFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"@ensofinance/weiroll/contracts/CommandBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\nlibrary CommandBuilder {\\n\\n    uint256 constant IDX_VARIABLE_LENGTH = 0x80;\\n    uint256 constant IDX_VALUE_MASK = 0x7f;\\n    uint256 constant IDX_END_OF_ARGS = 0xff;\\n    uint256 constant IDX_USE_STATE = 0xfe;\\n\\n    function buildInputs(\\n        bytes[] memory state,\\n        bytes4 selector,\\n        bytes32 indices\\n    ) internal view returns (bytes memory ret) {\\n        uint256 free; // Pointer to first free byte in tail part of message\\n        uint256 idx;\\n\\n        // Determine the length of the encoded data\\n        for (uint256 i; i < 32;) {\\n            idx = uint8(indices[i]);\\n            if (idx == IDX_END_OF_ARGS) break;\\n            unchecked{free += 32;}\\n            unchecked{++i;}\\n        }\\n\\n        // Encode it\\n        uint256 bytesWritten;\\n        assembly {\\n            ret := mload(0x40)\\n            bytesWritten := add(bytesWritten, 4)\\n            mstore(0x40, add(ret, and(add(add(bytesWritten, 0x20), 0x1f), not(0x1f))))\\n            mstore(add(ret, 32), selector)\\n        }\\n        uint256 count = 0;\\n        bytes memory stateData; // Optionally encode the current state if the call requires it\\n        for (uint256 i; i < 32;) {\\n            idx = uint8(indices[i]);\\n            if (idx == IDX_END_OF_ARGS) break;\\n\\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\\n                if (idx == IDX_USE_STATE) {\\n                    assembly {\\n                        bytesWritten := add(bytesWritten, 32)\\n                        mstore(0x40, add(ret, and(add(add(bytesWritten, 0x20), 0x1f), not(0x1f))))\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    if (stateData.length == 0) {\\n                        stateData = abi.encode(state);\\n                    }\\n                    assembly {\\n                        bytesWritten := add(bytesWritten, mload(stateData))\\n                        mstore(0x40, add(ret, and(add(add(bytesWritten, 0x20), 0x1f), not(0x1f))))\\n                    }\\n                    memcpy(stateData, 32, ret, free + 4, stateData.length - 32);\\n                    free += stateData.length - 32;\\n                } else {\\n                    bytes memory stateVar = state[idx & IDX_VALUE_MASK];\\n                    uint256 arglen = stateVar.length;\\n\\n                    // Variable length data; put a pointer in the slot and write the data at the end\\n                    assembly {\\n                        bytesWritten := add(bytesWritten, 32)\\n                        mstore(0x40, add(ret, and(add(add(bytesWritten, 0x20), 0x1f), not(0x1f))))\\n                        mstore(add(add(ret, 36), count), free)\\n                    }\\n                    assembly {\\n                        bytesWritten := add(bytesWritten, arglen)\\n                        mstore(0x40, add(ret, and(add(add(bytesWritten, 0x20), 0x1f), not(0x1f))))\\n                    }\\n                    memcpy(\\n                        stateVar,\\n                        0,\\n                        ret,\\n                        free + 4,\\n                        arglen\\n                    );\\n                    free += arglen;\\n                }\\n            } else {\\n                // Fixed length data; write it directly\\n                bytes memory stateVar = state[idx & IDX_VALUE_MASK];\\n                assembly {\\n                    bytesWritten := add(bytesWritten, mload(stateVar))\\n                    mstore(0x40, add(ret, and(add(add(bytesWritten, 0x20), 0x1f), not(0x1f))))\\n                    mstore(add(add(ret, 36), count), mload(add(stateVar, 32)))\\n                }\\n            }\\n            unchecked{count += 32;}\\n            unchecked{++i;}\\n        }\\n        assembly {\\n            mstore(ret, bytesWritten)\\n        }\\n    }\\n\\n    function writeOutputs(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal pure returns (bytes[] memory) {\\n        uint256 idx = uint8(index);\\n        if (idx == IDX_END_OF_ARGS) return state;\\n\\n        if (idx & IDX_VARIABLE_LENGTH != 0) {\\n            if (idx == IDX_USE_STATE) {\\n                state = abi.decode(output, (bytes[]));\\n            } else {\\n                // Check the first field is 0x20 (because we have only a single return value)\\n                uint256 argptr;\\n                assembly {\\n                    argptr := mload(add(output, 32))\\n                }\\n                require(\\n                    argptr == 32,\\n                    \\\"Only one return value permitted (variable)\\\"\\n                );\\n\\n                assembly {\\n                    // Overwrite the first word of the return data with the length - 32\\n                    mstore(add(output, 32), sub(mload(output), 32))\\n                    // Insert a pointer to the return data, starting at the second word, into state\\n                    mstore(\\n                        add(add(state, 32), mul(and(idx, IDX_VALUE_MASK), 32)),\\n                        add(output, 32)\\n                    )\\n                }\\n            }\\n        } else {\\n            // Single word\\n            require(\\n                output.length == 32,\\n                \\\"Only one return value permitted (static)\\\"\\n            );\\n\\n            state[idx & IDX_VALUE_MASK] = output;\\n        }\\n\\n        return state;\\n    }\\n\\n    function writeTuple(\\n        bytes[] memory state,\\n        bytes1 index,\\n        bytes memory output\\n    ) internal view {\\n        uint256 idx = uint256(uint8(index));\\n        if (idx == IDX_END_OF_ARGS) return;\\n\\n        bytes memory entry = state[idx] = new bytes(output.length + 32);\\n        memcpy(output, 0, entry, 32, output.length);\\n        assembly {\\n            let l := mload(output)\\n            mstore(add(entry, 32), l)\\n        }\\n    }\\n\\n    function memcpy(\\n        bytes memory src,\\n        uint256 srcidx,\\n        bytes memory dest,\\n        uint256 destidx,\\n        uint256 len\\n    ) internal view {\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    4,\\n                    add(add(src, 32), srcidx),\\n                    len,\\n                    add(add(dest, 32), destidx),\\n                    len\\n                )\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5b68bb05684562c869f10623e9cd7fee155aa0f24f0069f0e55df710d5784631\",\"license\":\"MIT\"},\"@ensofinance/weiroll/contracts/VM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\nimport \\\"./CommandBuilder.sol\\\";\\n\\nabstract contract VM {\\n    using CommandBuilder for bytes[];\\n\\n    uint256 constant FLAG_CT_DELEGATECALL = 0x00;\\n    uint256 constant FLAG_CT_CALL = 0x01;\\n    uint256 constant FLAG_CT_STATICCALL = 0x02;\\n    uint256 constant FLAG_CT_VALUECALL = 0x03;\\n    uint256 constant FLAG_CT_MASK = 0x03;\\n    uint256 constant FLAG_EXTENDED_COMMAND = 0x40;\\n    uint256 constant FLAG_TUPLE_RETURN = 0x80;\\n\\n    uint256 constant SHORT_COMMAND_FILL = 0x000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    address immutable self;\\n\\n    error ExecutionFailed(\\n        uint256 command_index,\\n        address target,\\n        string message\\n    );\\n\\n    constructor() {\\n        self = address(this);\\n    }\\n\\n    function _execute(bytes32[] calldata commands, bytes[] memory state)\\n      internal returns (bytes[] memory)\\n    {\\n        bytes32 command;\\n        uint256 flags;\\n        bytes32 indices;\\n\\n        bool success;\\n        bytes memory outdata;\\n\\n        uint256 commandsLength = commands.length;\\n        for (uint256 i; i < commandsLength;) {\\n            command = commands[i];\\n            flags = uint256(command >> 216) & 0xFF; // more efficient\\n            // flags = uint256(uint8(bytes1(command << 32))); // more readable \\n\\n            if (flags & FLAG_EXTENDED_COMMAND != 0) {\\n                indices = commands[++i];\\n            } else {\\n                indices = bytes32(uint256(command << 40) | SHORT_COMMAND_FILL);\\n            }\\n\\n            if (flags & FLAG_CT_MASK == FLAG_CT_DELEGATECALL) {\\n                (success, outdata) = address(uint160(uint256(command))).delegatecall( // target\\n                    // inputs\\n                    state.buildInputs(\\n                        //selector\\n                        bytes4(command),\\n                        indices\\n                    )\\n                );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_CALL) {\\n                (success, outdata) = address(uint160(uint256(command))).call( // target\\n                    // inputs\\n                    state.buildInputs(\\n                        //selector\\n                        bytes4(command),\\n                        indices\\n                    )\\n                );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_STATICCALL) {\\n                (success, outdata) = address(uint160(uint256(command))).staticcall( // target\\n                    // inputs\\n                    state.buildInputs(\\n                        //selector\\n                        bytes4(command),\\n                        indices\\n                    )\\n                );\\n            } else if (flags & FLAG_CT_MASK == FLAG_CT_VALUECALL) {\\n                uint256 callEth;\\n                bytes memory v = state[uint8(bytes1(indices))];\\n                require(v.length == 32, \\\"_execute: value call has no value indicated.\\\");\\n                assembly {\\n                    callEth := mload(add(v, 0x20))\\n                }\\n                (success, outdata) = address(uint160(uint256(command))).call{ // target\\n                    value: callEth\\n                }(\\n                    // inputs\\n                    state.buildInputs(\\n                        //selector\\n                        bytes4(command),\\n                        bytes32(uint256(indices << 8) | CommandBuilder.IDX_END_OF_ARGS)\\n                    )\\n                );\\n            } else {\\n                revert(\\\"Invalid calltype\\\");\\n            }\\n\\n            if (!success) {\\n                if (outdata.length > 0) {\\n                    assembly {\\n                        outdata := add(outdata, 68)\\n                    }\\n                }\\n                revert ExecutionFailed({\\n                    command_index: 0,\\n                    target: address(uint160(uint256(command))),\\n                    message: outdata.length > 0 ? string(outdata) : \\\"Unknown\\\"\\n                });\\n            }\\n\\n            if (flags & FLAG_TUPLE_RETURN != 0) {\\n                state.writeTuple(bytes1(command << 88), outdata);\\n            } else {\\n                state = state.writeOutputs(bytes1(command << 88), outdata);\\n            }\\n            unchecked{++i;}\\n        }\\n        return state;\\n    }\\n}\\n\",\"keccak256\":\"0x55430b4e804e771b5ba2e92b61ae36979a050d26675d204066258acb379c7827\",\"license\":\"MIT\"},\"contracts/Libraries/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n// Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Clones.sol\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, address salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        address salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x24935f7394af468793c51805881643eea06f3058ec824b0a30d5af9b7fb244a0\",\"license\":\"MIT\"},\"contracts/Portal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {VM} from \\\"@ensofinance/weiroll/contracts/VM.sol\\\";\\n\\ncontract Portal is VM {\\n    address public caller;\\n    bool public initialized;\\n\\n    // Already initialized\\n    error AlreadyInit();\\n    // Not caller\\n    error NotCaller();\\n    // Invalid address\\n    error InvalidAddress();\\n\\n    function initialize(\\n        address caller_,\\n        bytes32[] calldata commands,\\n        bytes[] calldata state\\n    ) external payable {\\n        if (initialized) revert AlreadyInit();\\n        caller = caller_;\\n        if (commands.length != 0) {\\n            _execute(commands, state);\\n        }\\n    }\\n\\n    function execute(bytes32[] calldata commands, bytes[] calldata state)\\n        external\\n        payable\\n        returns (bytes[] memory returnData)\\n    {\\n        if (msg.sender != caller) revert NotCaller();\\n        returnData = _execute(commands, state);\\n    }\\n\\n    receive() external payable {}\\n}\\n\",\"keccak256\":\"0x2539169311900371dc67b07a4dd406671a99a05e25fccd54a04b5e2463d2db0e\",\"license\":\"MIT\"},\"contracts/PortalFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Portal.sol\\\";\\nimport {Clones} from \\\"./Libraries/Clones.sol\\\";\\n\\ncontract PortalFactory {\\n    using Clones for address;\\n\\n    address public immutable portalImplementation;\\n\\n    event Deployed(Portal instance);\\n\\n    constructor(address portal_) {\\n        portalImplementation = portal_;\\n    }\\n\\n    function deploy(bytes32[] calldata commands, bytes[] calldata state) public payable returns (Portal instance) {\\n        instance = Portal(payable(portalImplementation.cloneDeterministic(msg.sender)));\\n        instance.initialize{value: msg.value}(msg.sender, commands, state);\\n\\n        emit Deployed(instance);\\n    }\\n\\n    function getAddress() public view returns (address payable) {\\n        return payable(portalImplementation.predictDeterministicAddress(msg.sender, address(this)));\\n    }\\n}\\n\",\"keccak256\":\"0x0a731faa0c79d42db5a11c412833eb1d111be715d49bd2456ee95ff9dfb31ef0\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161067e38038061067e83398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b6080516105e76100976000396000818160890152818160da015261019101526105e76000f3fe6080604052600436106100345760003560e01c806338cc48311461003957806395db804814610077578063abbea987146100ab575b600080fd5b34801561004557600080fd5b5061004e6100be565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b34801561008357600080fd5b5061004e7f000000000000000000000000000000000000000000000000000000000000000081565b61004e6100b93660046103b9565b610175565b600061017073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633306040517f3d602d80600a3d3981f3363d3d373d3d3d363d730000000000000000000000008152606093841b60148201527f5af43d82803e903d91602b57fd5bf3ff000000000000000000000000000000006028820152921b6038830152604c8201526037808220606c830152605591012090565b905090565b60006101b773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633610285565b90508073ffffffffffffffffffffffffffffffffffffffff166387258e8e3433888888886040518763ffffffff1660e01b81526004016101fb95949392919061046e565b6000604051808303818588803b15801561021457600080fd5b505af1158015610228573d6000803e3d6000fd5b505060405173ffffffffffffffffffffffffffffffffffffffff851681527ff40fcec21964ffb566044d083b4073f29f7f7929110ea19e1b3ebe375d89055e935060200191506102759050565b60405180910390a1949350505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528360601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152826037826000f591505073ffffffffffffffffffffffffffffffffffffffff8116610367576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f455243313136373a2063726561746532206661696c6564000000000000000000604482015260640160405180910390fd5b92915050565b60008083601f84011261037f57600080fd5b50813567ffffffffffffffff81111561039757600080fd5b6020830191508360208260051b85010111156103b257600080fd5b9250929050565b600080600080604085870312156103cf57600080fd5b843567ffffffffffffffff808211156103e757600080fd5b6103f38883890161036d565b9096509450602087013591508082111561040c57600080fd5b506104198782880161036d565b95989497509550505050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b73ffffffffffffffffffffffffffffffffffffffff86168152600060206060818401528560608401527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8611156104c457600080fd5b8560051b808860808601378301838103608090810160408601528101859052600585901b810160a09081019082018760005b888110156105a0577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6085850301835281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18b360301811261055757600080fd5b8a01803567ffffffffffffffff81111561057057600080fd5b8036038c131561057f57600080fd5b61058c86828a8501610425565b9550505091850191908501906001016104f6565b50919b9a505050505050505050505056fea2646970667358221220ca79fd07dd0624f6f0e8dfef0d4fc60e9fe3697d8132b1e207f1454b36aa2cab64736f6c634300080d0033",
  "deployedBytecode": "0x6080604052600436106100345760003560e01c806338cc48311461003957806395db804814610077578063abbea987146100ab575b600080fd5b34801561004557600080fd5b5061004e6100be565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b34801561008357600080fd5b5061004e7f000000000000000000000000000000000000000000000000000000000000000081565b61004e6100b93660046103b9565b610175565b600061017073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633306040517f3d602d80600a3d3981f3363d3d373d3d3d363d730000000000000000000000008152606093841b60148201527f5af43d82803e903d91602b57fd5bf3ff000000000000000000000000000000006028820152921b6038830152604c8201526037808220606c830152605591012090565b905090565b60006101b773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001633610285565b90508073ffffffffffffffffffffffffffffffffffffffff166387258e8e3433888888886040518763ffffffff1660e01b81526004016101fb95949392919061046e565b6000604051808303818588803b15801561021457600080fd5b505af1158015610228573d6000803e3d6000fd5b505060405173ffffffffffffffffffffffffffffffffffffffff851681527ff40fcec21964ffb566044d083b4073f29f7f7929110ea19e1b3ebe375d89055e935060200191506102759050565b60405180910390a1949350505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528360601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152826037826000f591505073ffffffffffffffffffffffffffffffffffffffff8116610367576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f455243313136373a2063726561746532206661696c6564000000000000000000604482015260640160405180910390fd5b92915050565b60008083601f84011261037f57600080fd5b50813567ffffffffffffffff81111561039757600080fd5b6020830191508360208260051b85010111156103b257600080fd5b9250929050565b600080600080604085870312156103cf57600080fd5b843567ffffffffffffffff808211156103e757600080fd5b6103f38883890161036d565b9096509450602087013591508082111561040c57600080fd5b506104198782880161036d565b95989497509550505050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b73ffffffffffffffffffffffffffffffffffffffff86168152600060206060818401528560608401527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8611156104c457600080fd5b8560051b808860808601378301838103608090810160408601528101859052600585901b810160a09081019082018760005b888110156105a0577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6085850301835281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18b360301811261055757600080fd5b8a01803567ffffffffffffffff81111561057057600080fd5b8036038c131561057f57600080fd5b61058c86828a8501610425565b9550505091850191908501906001016104f6565b50919b9a505050505050505050505056fea2646970667358221220ca79fd07dd0624f6f0e8dfef0d4fc60e9fe3697d8132b1e207f1454b36aa2cab64736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
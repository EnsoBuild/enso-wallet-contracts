{
  "address": "0xF60803F55ae2Ff159EfF39aa21e8EDD1b9a3d1B3",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "tuple",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "extractArray",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "tuple",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "extractDynamicArray",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "tuple",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "extractDynamicElement",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "tuple",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "extractElement",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "tuple",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "bool[]",
          "name": "isDynamicTypeFormat",
          "type": "bool[]"
        }
      ],
      "name": "extractTuple",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "tuple",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "bool[]",
          "name": "isDynamicTypeFormat",
          "type": "bool[]"
        }
      ],
      "name": "extractTupleArray",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x7480db856f4758d523126ba64b9a982724f991d13ebd816ec50acb7cddfa5038",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xf754916D90B109AE8E405FD34064cF6Df23947eb",
    "contractAddress": null,
    "transactionIndex": 73,
    "gasUsed": "409597",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000400000000100000000000000000000000000000000000000000000000000000000000080000000000001000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000004000008000000000000000000000000000000000000000000000100000",
    "blockHash": "0x9455f5d8aff12d2b23835a27c7bff305454d8f6b6c271492961448461edcc19b",
    "transactionHash": "0x7480db856f4758d523126ba64b9a982724f991d13ebd816ec50acb7cddfa5038",
    "logs": [
      {
        "transactionIndex": 73,
        "blockNumber": 35672331,
        "transactionHash": "0x7480db856f4758d523126ba64b9a982724f991d13ebd816ec50acb7cddfa5038",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000f754916d90b109ae8e405fd34064cf6df23947eb",
          "0x0000000000000000000000007c7379531b2aee82e4ca06d4175d13b9cbeafd49"
        ],
        "data": "0x000000000000000000000000000000000000000000000000002bfc7cd511e55f00000000000000000000000000000000000000000000000536b490dc7238bd8200000000000000000000000000000000000000000001a8d2ed3484ef9940e1ac0000000000000000000000000000000000000000000000053688945f9d26d82300000000000000000000000000000000000000000001a8d2ed60816c6e52c70b",
        "logIndex": 286,
        "blockHash": "0x9455f5d8aff12d2b23835a27c7bff305454d8f6b6c271492961448461edcc19b"
      }
    ],
    "blockNumber": 35672331,
    "cumulativeGasUsed": "11136949",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "c5bd95db501c40a4c333b1143683ebdd",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tuple\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"extractArray\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tuple\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"extractDynamicArray\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tuple\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"extractDynamicElement\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tuple\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"extractElement\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tuple\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool[]\",\"name\":\"isDynamicTypeFormat\",\"type\":\"bool[]\"}],\"name\":\"extractTuple\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tuple\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool[]\",\"name\":\"isDynamicTypeFormat\",\"type\":\"bool[]\"}],\"name\":\"extractTupleArray\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"extractArray(bytes,uint256)\":{\"details\":\"Use with .rawValue() in the weiroll planner\",\"params\":{\"index\":\"The index of the array to be extracted\",\"tuple\":\"The bytes encoded array\"}},\"extractDynamicArray(bytes,uint256)\":{\"details\":\"Use with .rawValue() in the weiroll planner\",\"params\":{\"index\":\"The index of the dynamic array to be extracted\",\"tuple\":\"The bytes encoded tuple\"}},\"extractDynamicElement(bytes,uint256)\":{\"details\":\"Use with .rawValue() in the weiroll planner\",\"params\":{\"index\":\"The index of the string or bytes to be extracted\",\"tuple\":\"The bytes encoded tuple\"}},\"extractElement(bytes,uint256)\":{\"details\":\"Use with .rawValue() in the weiroll planner\",\"params\":{\"index\":\"The index of the value to be extracted\",\"tuple\":\"The bytes encoded tuple\"}},\"extractTuple(bytes,uint256,bool[])\":{\"details\":\"Use with .rawValue() in the weiroll planner\",\"params\":{\"index\":\"The index of the tuple to be extracted\",\"isDynamicTypeFormat\":\"Boolean to define whether the child tuple is dynamically sized. If the child tuple contains bytes or string variables, set to \\\"true\\\"\",\"tuple\":\"The bytes encoded parent tuple\"}},\"extractTupleArray(bytes,uint256,bool[])\":{\"details\":\"Use with .rawValue() in the weiroll planner\",\"params\":{\"index\":\"The index of the tuple array to be extracted\",\"isDynamicTypeFormat\":\"Boolean to define whether the tuples in the array are dynamically sized. If the array tuple contains bytes or string variables, set to \\\"true\\\"\",\"tuple\":\"The bytes encoded tuple\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"extractArray(bytes,uint256)\":{\"notice\":\"Extract a bytes encoded static array from a tuple\"},\"extractDynamicArray(bytes,uint256)\":{\"notice\":\"Extract a bytes encoded dynamic array from a tuple\"},\"extractDynamicElement(bytes,uint256)\":{\"notice\":\"Extract a bytes encoded dynamic type from a tuple\"},\"extractElement(bytes,uint256)\":{\"notice\":\"Extract a bytes32 encoded static type from a tuple\"},\"extractTuple(bytes,uint256,bool[])\":{\"notice\":\"Extract a bytes encoded tuple from another tuple\"},\"extractTupleArray(bytes,uint256,bool[])\":{\"notice\":\"Extract a bytes encoded array of tuples from a tuple\"}},\"notice\":\"Helper contract to extract a variety of types from a tuple within the context of a weiroll script\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/helpers/TupleHelpers.sol\":\"TupleHelpers\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/helpers/TupleHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n  * @notice Helper contract to extract a variety of types from a tuple within the context of a weiroll script\\n  */\\ncontract TupleHelpers {\\n\\n    /**\\n      * @notice Extract a bytes32 encoded static type from a tuple\\n      * @dev Use with .rawValue() in the weiroll planner\\n      * @param tuple The bytes encoded tuple\\n      * @param index The index of the value to be extracted\\n      */\\n    function extractElement(bytes memory tuple, uint256 index) public pure returns (bytes32) {\\n        assembly {\\n            // let offset := mul(add(index, 1), 32)\\n            // return(add(tuple, offset), 32)\\n            return(add(tuple, mul(add(index, 1), 32)), 32)\\n        }\\n    }\\n\\n    /**\\n      * @notice Extract a bytes encoded dynamic type from a tuple\\n      * @dev Use with .rawValue() in the weiroll planner\\n      * @param tuple The bytes encoded tuple\\n      * @param index The index of the string or bytes to be extracted\\n      */\\n    function extractDynamicElement(bytes memory tuple, uint256 index) public pure returns (bytes32) {\\n        assembly {\\n            let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\\n            let length := mload(add(tuple, offset))\\n            if gt(mod(length, 32), 0) {\\n              length := mul(add(div(length, 32), 1), 32)\\n            }\\n            return(add(tuple, add(offset, 32)), length)\\n        }\\n    }\\n\\n    /**\\n      * @notice Extract a bytes encoded tuple from another tuple\\n      * @dev Use with .rawValue() in the weiroll planner\\n      * @param tuple The bytes encoded parent tuple\\n      * @param index The index of the tuple to be extracted\\n      * @param isDynamicTypeFormat Boolean to define whether the child tuple is dynamically sized. If the child tuple contains bytes or string variables, set to \\\"true\\\"\\n      */\\n    function extractTuple(\\n        bytes memory tuple,\\n        uint256 index,\\n        bool[] memory isDynamicTypeFormat\\n    ) public pure returns (bytes32) {\\n        uint256 offset;\\n        uint256 length;\\n        assembly {\\n            offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\\n        }\\n        for (uint256 i = 0; i < isDynamicTypeFormat.length; i++) {\\n            length += 32;\\n            if (isDynamicTypeFormat[i]) {\\n                assembly {\\n                    let paramOffset := add(offset, mload(add(tuple, add(offset, mul(i, 32)))))\\n                    let paramLength := add(mload(add(tuple, paramOffset)), 32)\\n                    if gt(mod(paramLength, 32), 0) {\\n                      paramLength := mul(add(div(paramLength, 32), 1), 32)\\n                    }\\n                    length := add(length, paramLength)\\n                }\\n            }\\n        }\\n        assembly {\\n            return(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)), length)\\n        }\\n    }\\n\\n    /**\\n      * @notice Extract a bytes encoded static array from a tuple\\n      * @dev Use with .rawValue() in the weiroll planner\\n      * @param tuple The bytes encoded array\\n      * @param index The index of the array to be extracted\\n      */\\n    function extractArray(bytes memory tuple, uint256 index) public pure returns (bytes32) {\\n        assembly {\\n            // let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\\n            // let numberOfElements := mload(add(tuple, offset))\\n            // return(add(tuple, add(offset, 32)), mul(numberOfElements, 32))\\n            return(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)), mul(mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32))), 32))\\n        }\\n    }\\n\\n    /**\\n      * @notice Extract a bytes encoded dynamic array from a tuple\\n      * @dev Use with .rawValue() in the weiroll planner\\n      * @param tuple The bytes encoded tuple\\n      * @param index The index of the dynamic array to be extracted\\n      */\\n    function extractDynamicArray(bytes memory tuple, uint256 index) public pure returns (bytes32) {\\n        uint256 numberOfElements;\\n        uint256 offset;\\n        assembly {\\n            offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\\n            numberOfElements := mload(add(tuple, offset))\\n            //numberOfElements := mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)))\\n        }\\n\\n        uint256 length;\\n        for (uint256 i = 1; i <= numberOfElements; i++) {\\n            assembly {\\n                let paramOffset := add(offset, mul(add(i, 1), 32))\\n                let paramLength := mload(add(tuple, paramOffset))\\n                if gt(mod(paramLength, 32), 0) {\\n                  paramLength := mul(add(div(paramLength, 32), 1), 32)\\n                }\\n                length := add(length, paramLength)\\n                //length := add(length, mload(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), mul(add(i, 1), 32)))))\\n            }\\n        }\\n        assembly {\\n            // return(add(tuple, add(offset, 32)), add(length, 32))\\n            return(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), 32)), add(length, 32))\\n        }\\n    }\\n\\n    /**\\n      * @notice Extract a bytes encoded array of tuples from a tuple\\n      * @dev Use with .rawValue() in the weiroll planner\\n      * @param tuple The bytes encoded tuple\\n      * @param index The index of the tuple array to be extracted\\n      * @param isDynamicTypeFormat Boolean to define whether the tuples in the array are dynamically sized. If the array tuple contains bytes or string variables, set to \\\"true\\\"\\n      */\\n    function extractTupleArray(\\n        bytes memory tuple,\\n        uint256 index,\\n        bool[] memory isDynamicTypeFormat\\n    ) public pure returns (bytes32) {\\n        uint256 numberOfElements;\\n        assembly {\\n            // let offset := add(mload(add(tuple, mul(add(index, 1), 32))), 32)\\n            // numberOfElements := mload(add(tuple, offset))\\n            numberOfElements := mload(add(tuple, add(mload(add(tuple, mul(add(index, 1), 32))), 32)))\\n        }\\n        uint256 length = numberOfElements * 32;\\n        for (uint256 i = 1; i <= numberOfElements; i++) {\\n            for (uint256 j = 0; j < isDynamicTypeFormat.length; j++) {\\n                length += 32;\\n                if (isDynamicTypeFormat[j]) {\\n                    assembly {\\n                        // let tupleOffset := add(offset,mload(add(tuple, add(offset, mul(i, 32)))))\\n                        // let paramOffset := add(tupleOffset, mload(add(tuple, add(tupleOffset, mul(add(j,1), 32)))))\\n                        // let paramLength := add(mload(add(tuple, paramOffset)),32)\\n                        // length := add(length, paramLength)\\n                        length := add(length, add(mload(add(tuple, add(add(add(mload(add(tuple, mul(add(index, 1), 32))), 32),mload(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), mul(i, 32))))), mload(add(tuple, add(add(add(mload(add(tuple, mul(add(index, 1), 32))), 32),mload(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32), mul(i, 32))))), mul(add(j,1), 32))))))),32))\\n                    }\\n                }\\n            }\\n        }\\n        assembly {\\n            // return(add(tuple, add(offset,32)), length)\\n            return(add(tuple, add(add(mload(add(tuple, mul(add(index, 1), 32))), 32),32)), length)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x00c75d557630f6f26a0bff0cc919a71207def365bbcaee588119d5946dc187bc\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001657610673908161001c8239f35b600080fdfe60806040526004361015610013575b600080fd5b60003560e01c80632fb402541461008b57806348f26302146100825780635305afc0146100795780639bd3b22714610070578063a208b031146100675763df6d76b51461005f57600080fd5b61000e61050c565b5061000e610448565b5061000e61042b565b5061000e6103ab565b5061000e61036b565b3461000e576100993661024b565b91600091600180948160059301831b840192835186975b6100bf575b8660208787510101f35b909192958351881015610145576100d5906105a0565b966100e96100e382866105b8565b51151590565b610103575b906100f98792610566565b97969392916100b0565b96906100f987926020908482808d891b87018c01015186018b01015192808085019408610137575b500198919250506100ee565b9091861c01851b908461012b565b956100b5565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f604051930116820182811067ffffffffffffffff8211176101bf57604052565b6101c761014b565b604052565b81601f8201121561000e5780359067ffffffffffffffff821161023e575b61021b60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8501160161017b565b928284526020838301011161000e57816000926020809301838601378301015290565b61024661014b565b6101ea565b60607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82011261000e5767ffffffffffffffff9160043583811161000e5782610296916004016101cc565b92602435926044359082821161000e578060238301121561000e57816004013592831161030e575b8260051b6020926024846102d381850161017b565b80978152019282010192831161000e57602401905b8282106102f6575050505090565b8135801515810361000e5781529083019083016102e8565b61031661014b565b6102be565b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82011261000e576004359067ffffffffffffffff821161000e57610364916004016101cc565b9060243590565b503461000e57600161037c3661031b565b9190910160051b81015101602081015190601f821661039a57604001f35b600591821c60010190911b90604001f35b503461000e576103ba3661031b565b6001918260059201821b81019182519360209182868501015160009280925b828411156103ee578760408888880192510101f35b909192936104159086848701841b8b01890101519084601f831661041d575b500194610566565b9291906103d9565b9091841c01831b908461040d565b503461000e576020600161043e3661031b565b9190910160051b01f35b503461000e576104573661024b565b909160018060059401841b82019060208083518501015194610478866105fb565b96835b8781111561048d578860408888510101f35b6000855b6104a5575b506104a090610566565b61047b565b9883518a1015610506576104b8906105a0565b986104c66100e382866105b8565b6104db575b6104d58691610566565b90610491565b865182841b8101890186015101818701841b81018901860151018801850151999099018401986104cb565b98610496565b503461000e57600161051d3661031b565b9190910160051b810151016040602082015160051b9101f35b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6001907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610594570190565b61059c610536565b0190565b90602082018092116105ae57565b6105b6610536565b565b80518210156105cc5760209160051b010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0460201181151516610630575b60051b90565b610638610536565b61062a56fea26469706673582212209b97fccde51caabba1d2eae7225ae59291be4921a57a7c41449e220c349fb92964736f6c63430008100033",
  "deployedBytecode": "0x60806040526004361015610013575b600080fd5b60003560e01c80632fb402541461008b57806348f26302146100825780635305afc0146100795780639bd3b22714610070578063a208b031146100675763df6d76b51461005f57600080fd5b61000e61050c565b5061000e610448565b5061000e61042b565b5061000e6103ab565b5061000e61036b565b3461000e576100993661024b565b91600091600180948160059301831b840192835186975b6100bf575b8660208787510101f35b909192958351881015610145576100d5906105a0565b966100e96100e382866105b8565b51151590565b610103575b906100f98792610566565b97969392916100b0565b96906100f987926020908482808d891b87018c01015186018b01015192808085019408610137575b500198919250506100ee565b9091861c01851b908461012b565b956100b5565b507f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f604051930116820182811067ffffffffffffffff8211176101bf57604052565b6101c761014b565b604052565b81601f8201121561000e5780359067ffffffffffffffff821161023e575b61021b60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8501160161017b565b928284526020838301011161000e57816000926020809301838601378301015290565b61024661014b565b6101ea565b60607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82011261000e5767ffffffffffffffff9160043583811161000e5782610296916004016101cc565b92602435926044359082821161000e578060238301121561000e57816004013592831161030e575b8260051b6020926024846102d381850161017b565b80978152019282010192831161000e57602401905b8282106102f6575050505090565b8135801515810361000e5781529083019083016102e8565b61031661014b565b6102be565b60407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc82011261000e576004359067ffffffffffffffff821161000e57610364916004016101cc565b9060243590565b503461000e57600161037c3661031b565b9190910160051b81015101602081015190601f821661039a57604001f35b600591821c60010190911b90604001f35b503461000e576103ba3661031b565b6001918260059201821b81019182519360209182868501015160009280925b828411156103ee578760408888880192510101f35b909192936104159086848701841b8b01890101519084601f831661041d575b500194610566565b9291906103d9565b9091841c01831b908461040d565b503461000e576020600161043e3661031b565b9190910160051b01f35b503461000e576104573661024b565b909160018060059401841b82019060208083518501015194610478866105fb565b96835b8781111561048d578860408888510101f35b6000855b6104a5575b506104a090610566565b61047b565b9883518a1015610506576104b8906105a0565b986104c66100e382866105b8565b6104db575b6104d58691610566565b90610491565b865182841b8101890186015101818701841b81018901860151018801850151999099018401986104cb565b98610496565b503461000e57600161051d3661031b565b9190910160051b810151016040602082015160051b9101f35b507f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6001907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114610594570190565b61059c610536565b0190565b90602082018092116105ae57565b6105b6610536565b565b80518210156105cc5760209160051b010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0460201181151516610630575b60051b90565b610638610536565b61062a56fea26469706673582212209b97fccde51caabba1d2eae7225ae59291be4921a57a7c41449e220c349fb92964736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "extractArray(bytes,uint256)": {
        "details": "Use with .rawValue() in the weiroll planner",
        "params": {
          "index": "The index of the array to be extracted",
          "tuple": "The bytes encoded array"
        }
      },
      "extractDynamicArray(bytes,uint256)": {
        "details": "Use with .rawValue() in the weiroll planner",
        "params": {
          "index": "The index of the dynamic array to be extracted",
          "tuple": "The bytes encoded tuple"
        }
      },
      "extractDynamicElement(bytes,uint256)": {
        "details": "Use with .rawValue() in the weiroll planner",
        "params": {
          "index": "The index of the string or bytes to be extracted",
          "tuple": "The bytes encoded tuple"
        }
      },
      "extractElement(bytes,uint256)": {
        "details": "Use with .rawValue() in the weiroll planner",
        "params": {
          "index": "The index of the value to be extracted",
          "tuple": "The bytes encoded tuple"
        }
      },
      "extractTuple(bytes,uint256,bool[])": {
        "details": "Use with .rawValue() in the weiroll planner",
        "params": {
          "index": "The index of the tuple to be extracted",
          "isDynamicTypeFormat": "Boolean to define whether the child tuple is dynamically sized. If the child tuple contains bytes or string variables, set to \"true\"",
          "tuple": "The bytes encoded parent tuple"
        }
      },
      "extractTupleArray(bytes,uint256,bool[])": {
        "details": "Use with .rawValue() in the weiroll planner",
        "params": {
          "index": "The index of the tuple array to be extracted",
          "isDynamicTypeFormat": "Boolean to define whether the tuples in the array are dynamically sized. If the array tuple contains bytes or string variables, set to \"true\"",
          "tuple": "The bytes encoded tuple"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "extractArray(bytes,uint256)": {
        "notice": "Extract a bytes encoded static array from a tuple"
      },
      "extractDynamicArray(bytes,uint256)": {
        "notice": "Extract a bytes encoded dynamic array from a tuple"
      },
      "extractDynamicElement(bytes,uint256)": {
        "notice": "Extract a bytes encoded dynamic type from a tuple"
      },
      "extractElement(bytes,uint256)": {
        "notice": "Extract a bytes32 encoded static type from a tuple"
      },
      "extractTuple(bytes,uint256,bool[])": {
        "notice": "Extract a bytes encoded tuple from another tuple"
      },
      "extractTupleArray(bytes,uint256,bool[])": {
        "notice": "Extract a bytes encoded array of tuples from a tuple"
      }
    },
    "notice": "Helper contract to extract a variety of types from a tuple within the context of a weiroll script",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}